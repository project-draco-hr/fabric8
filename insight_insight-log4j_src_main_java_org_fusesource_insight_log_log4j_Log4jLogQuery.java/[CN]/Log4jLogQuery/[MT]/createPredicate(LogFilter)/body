{
  if (filter == null) {
    return null;
  }
  final List<Predicate<LogEvent>> predicates=new ArrayList<Predicate<LogEvent>>();
  final Set<String> levels=filter.getLevelsSet();
  if (levels.size() > 0) {
    predicates.add(new Predicate<LogEvent>(){
      @Override public boolean matches(      LogEvent event){
        String level=event.getLevel();
        return level != null && levels.contains(level.toString());
      }
    }
);
  }
  final Long before=filter.getBeforeTimestamp();
  if (before != null) {
    final Date date=new Date(before);
    predicates.add(new Predicate<LogEvent>(){
      @Override public boolean matches(      LogEvent event){
        Date time=event.getTimestamp();
        return time != null && time.before(date);
      }
    }
);
  }
  final Long after=filter.getAfterTimestamp();
  if (after != null) {
    final Date date=new Date(after);
    predicates.add(new Predicate<LogEvent>(){
      @Override public boolean matches(      LogEvent event){
        Date time=event.getTimestamp();
        return time != null && time.after(date);
      }
    }
);
  }
  final String matchesText=filter.getMatchesText();
  if (matchesText != null && matchesText.length() > 0) {
    predicates.add(new Predicate<LogEvent>(){
      @Override public boolean matches(      LogEvent event){
        if (contains(matchesText,event.getClassName(),event.getMessage(),event.getLogger(),event.getThread())) {
          return true;
        }
        String[] throwableStrRep=event.getException();
        if (throwableStrRep != null && contains(matchesText,throwableStrRep)) {
          return true;
        }
        Map properties=event.getProperties();
        if (properties != null && contains(matchesText,properties.toString())) {
          return true;
        }
        return false;
      }
    }
);
  }
  if (predicates.size() == 0) {
    return null;
  }
 else   if (predicates.size() == 1) {
    return predicates.get(0);
  }
 else {
    return new Predicate<LogEvent>(){
      @Override public String toString(){
        return "AndPredicate" + predicates;
      }
      @Override public boolean matches(      LogEvent event){
        for (        Predicate<LogEvent> predicate : predicates) {
          if (!predicate.matches(event)) {
            return false;
          }
        }
        return true;
      }
    }
;
  }
}
