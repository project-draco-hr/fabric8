{
  moduleId=connection.getVersionedDependencyId();
  if (moduleId == null) {
    return;
  }
  processFabInstructions();
  sharedFilter=DependencyTreeFilters.parseShareFilter(join(sharedFilterPatterns," "));
  requireBundleFilter=DependencyTreeFilters.parseRequireBundleFilter(join(requireBundleFilterPatterns," "));
  optionalDependencyFilter=DependencyTreeFilters.parseExcludeOptionalFilter(join(optionalDependencyPatterns," "));
  excludeDependencyFilter=DependencyTreeFilters.parseExcludeFilter(join(excludeDependencyFilterPatterns," "),optionalDependencyFilter);
  importExportFilter=DependencyTreeFilters.parse(join(importExportFilterPatterns," "));
  bundleClassPath.addAll(Strings.splitAsList(getContainerManifestProperty(ServiceConstants.INSTR_BUNDLE_CLASSPATH),","));
  requireBundles.addAll(Strings.splitAsList(getContainerManifestProperty(ServiceConstants.INSTR_REQUIRE_BUNDLE),","));
  importPackages.putAll(new Analyzer().parseHeader(emptyIfNull(getContainerManifestProperty(ServiceConstants.INSTR_IMPORT_PACKAGE))));
  Filter<Dependency> optionalFilter=DependencyFilters.parseExcludeOptionalFilter(join(optionalDependencyPatterns," "));
  Filter<Dependency> excludeFilter=DependencyFilters.parseExcludeFilter(join(excludeDependencyFilterPatterns," "),optionalFilter);
  this.rootTree=connection.collectDependencyTree(offline,excludeFilter);
  for (  Filter<DependencyTree> filter : pruningFilters) {
    DependencyTreeFilters.prune(rootTree,filter);
  }
  String name=getContainerManifestProperty(ServiceConstants.INSTR_BUNDLE_SYMBOLIC_NAME);
  if (name.length() <= 0) {
    name=rootTree.getBundleSymbolicName();
    instructions.setProperty(ServiceConstants.INSTR_BUNDLE_SYMBOLIC_NAME,name);
  }
  String bundleVersion=getContainerManifestProperty(Analyzer.BUNDLE_VERSION);
  if (bundleVersion.length() <= 0) {
    bundleVersion=VersionCleaner.clean(rootTree.getVersion());
    instructions.setProperty(Analyzer.BUNDLE_VERSION,bundleVersion);
  }
  for (  String propertyName : ServiceConstants.FAB_PROPERTY_NAMES) {
    String value=getContainerManifestProperty(propertyName);
    if (value != null) {
      instructions.setProperty(propertyName,value);
    }
  }
  LOG.debug("Resolving Dependencies for: " + rootTree.getDependencyId());
  addDependencies(rootTree);
  ModuleRegistry.VersionedModule module=moduleRegistry.getVersionedModule(moduleId);
  if (module == null || module.getFile() != null) {
    registerModule();
  }
  resolveExtensions(rootTree,excludeFilter);
  for (  DependencyTree dependencyTree : sharedDependencies) {
    if (requireBundleFilter.matches(dependencyTree)) {
      String bundleId=dependencyTree.getBundleSymbolicName();
      Version version=new Version(VersionCleaner.clean(dependencyTree.getVersion()));
      requireBundles.add(bundleId + ";bundle-version=" + version+ "");
    }
 else {
      if (processImportPackages) {
        importAllExportedPackages(dependencyTree);
      }
    }
  }
  for (  DependencyTree dependencyTree : nonSharedDependencies) {
    if (dependencyTree.isValidLibrary()) {
      String url=dependencyTree.getUrl();
      if (url != null) {
        String path=dependencyTree.getGroupId() + "." + dependencyTree.getArtifactId()+ ".jar";
        if (!bundleClassPath.contains(path)) {
          File file=new File(url);
          if (file.exists()) {
            embeddedResources.put(path,file);
          }
 else {
            embeddedResources.put(path,new URL(url));
          }
          addBundleClassPath(path);
        }
      }
    }
  }
  nonSharedDependencies=filterOutDuplicates(nonSharedDependencies);
  sharedDependencies=filterOutDuplicates(sharedDependencies);
  installDependencies=filterOutDuplicates(installDependencies);
  optionalDependencies=filterOutDuplicates(optionalDependencies);
  LOG.debug("Required features:");
  for (  String feature : getInstallFeatures()) {
    LOG.debug("- " + feature);
  }
  LOG.debug("nonSharedDependencies:");
  for (  DependencyTree d : nonSharedDependencies) {
    LOG.debug("  " + d.getDependencyId());
  }
  LOG.debug("sharedDependencies:");
  for (  DependencyTree d : sharedDependencies) {
    LOG.debug("  " + d.getDependencyId());
  }
  LOG.debug("installDependencies:");
  for (  DependencyTree d : installDependencies) {
    LOG.debug("  " + d.getDependencyId());
  }
  LOG.debug("resolved: bundleClassPath: " + Strings.join(bundleClassPath,"\t\n"));
  LOG.debug("resolved: requireBundles: " + Strings.join(requireBundles,"\t\n"));
  LOG.debug("resolved: importPackages: " + Strings.join(importPackages.keySet(),"\t\n"));
  instructions.setProperty(ServiceConstants.INSTR_BUNDLE_CLASSPATH,Strings.join(bundleClassPath,","));
  instructions.setProperty(ServiceConstants.INSTR_REQUIRE_BUNDLE,Strings.join(requireBundles,","));
  instructions.setProperty(ServiceConstants.INSTR_FAB_MODULE_ID,moduleId.toString());
  if (!sharedFilterPatterns.isEmpty()) {
    instructions.setProperty(ServiceConstants.INSTR_FAB_PROVIDED_DEPENDENCY,join(sharedFilterPatterns," "));
  }
  if (!requireBundleFilterPatterns.isEmpty()) {
    instructions.setProperty(ServiceConstants.INSTR_FAB_DEPENDENCY_REQUIRE_BUNDLE,join(requireBundleFilterPatterns," "));
  }
  if (!excludeDependencyFilterPatterns.isEmpty()) {
    instructions.setProperty(ServiceConstants.INSTR_FAB_EXCLUDE_DEPENDENCY,join(excludeDependencyFilterPatterns," "));
  }
  if (!optionalDependencyPatterns.isEmpty()) {
    instructions.setProperty(ServiceConstants.INSTR_FAB_OPTIONAL_DEPENDENCY,join(optionalDependencyPatterns," "));
  }
}
