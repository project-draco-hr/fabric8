{
  assertValid();
  try {
    final ContainerProvider provider=getProvider(options.getProviderType());
    if (provider == null) {
      throw new FabricException("Unable to find a container provider supporting '" + options.getProviderType() + "'");
    }
    if (!provider.isValidProvider()) {
      throw new FabricException("The provider '" + options.getProviderType() + "' is not valid in current environment");
    }
    String originalName=options.getName();
    if (originalName == null || originalName.length() == 0) {
      throw new FabricException("A name must be specified when creating containers");
    }
    if (listener == null) {
      listener=new NullCreationStateListener();
    }
    validateProfileDependencies(options);
    ObjectMapper mapper=new ObjectMapper();
    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);
    Map optionsMap=mapper.readValue(mapper.writeValueAsString(options),Map.class);
    String versionId=options.getVersion() != null ? options.getVersion() : dataStore.get().getDefaultVersion();
    Set<String> profileIds=options.getProfiles();
    if (profileIds == null || profileIds.isEmpty()) {
      profileIds=new LinkedHashSet<String>();
      profileIds.add("default");
    }
    optionsMap.put("version",versionId);
    optionsMap.put("profiles",profileIds);
    optionsMap.put("number",0);
    final List<CreateContainerMetadata> metadatas=new CopyOnWriteArrayList<CreateContainerMetadata>();
    int orgNumber=options.getNumber();
    int number=Math.max(orgNumber,1);
    final CountDownLatch latch=new CountDownLatch(number);
    Set<String> ignoreContainerNames=new HashSet<>();
    Container[] containers=getContainers();
    for (    Container container : containers) {
      if (container.getId().equals(options.getName())) {
        throw new IllegalArgumentException("A container with name " + options.getName() + " already exists.");
      }
    }
    for (int i=1; i <= number; i++) {
      NameValidator validator=Containers.createNameValidator(containers,ignoreContainerNames);
      final String containerName=Containers.createUniqueContainerName(containers,originalName,validator);
      ignoreContainerNames.add(containerName);
      optionsMap.put("name",containerName);
      if (!hasValidDataStoreProperties(optionsMap)) {
        optionsMap.put("dataStoreProperties",profileRegistry.get().getDataStoreProperties());
      }
      Class cl=options.getClass().getClassLoader().loadClass(options.getClass().getName() + "$Builder");
      CreateContainerBasicOptions.Builder builder=(CreateContainerBasicOptions.Builder)mapper.readValue(mapper.writeValueAsString(optionsMap),cl);
      builder=(CreateContainerBasicOptions.Builder)builder.zookeeperPassword(PasswordEncoder.encode(getZookeeperPassword()));
      final CreateContainerOptions containerOptions=builder.build();
      final CreationStateListener containerListener=listener;
      final FabricService fabricService=this;
      new Thread("Creating container " + containerName){
        public void run(){
          try {
            if (dataStore.get().hasContainer(containerName)) {
              CreateContainerBasicMetadata metadata=new CreateContainerBasicMetadata();
              metadata.setContainerName(containerName);
              metadata.setCreateOptions(containerOptions);
              metadata.setFailure(new IllegalArgumentException("A container with name " + containerName + " already exists."));
              metadatas.add(metadata);
              return;
            }
            dataStore.get().createContainerConfig(containerOptions);
            CreateContainerMetadata metadata=provider.create(containerOptions,containerListener);
            if (metadata.isSuccess()) {
              Container parent=containerOptions.getParent() != null ? getContainer(containerOptions.getParent()) : null;
              if (!containerOptions.isEnsembleServer()) {
                dataStore.get().createContainerConfig(metadata);
              }
              ContainerImpl container=new ContainerImpl(parent,metadata.getContainerName(),FabricServiceImpl.this);
              metadata.setContainer(container);
              LOGGER.info("The container " + metadata.getContainerName() + " has been successfully created");
            }
 else {
              LOGGER.info("The creation of the container " + metadata.getContainerName() + " has failed",metadata.getFailure());
            }
            metadatas.add(metadata);
          }
 catch (          Throwable t) {
            CreateContainerBasicMetadata metadata=new CreateContainerBasicMetadata();
            metadata.setContainerName(containerName);
            metadata.setCreateOptions(containerOptions);
            metadata.setFailure(t);
            metadatas.add(metadata);
            dataStore.get().deleteContainer(fabricService,containerOptions.getName());
          }
 finally {
            latch.countDown();
          }
        }
      }
.start();
    }
    if (!latch.await(30,TimeUnit.MINUTES)) {
      throw new FabricException("Timeout waiting for container creation");
    }
    return metadatas.toArray(new CreateContainerMetadata[metadatas.size()]);
  }
 catch (  Exception e) {
    LOGGER.error("Failed to create containers " + e,e);
    throw FabricException.launderThrowable(e);
  }
}
