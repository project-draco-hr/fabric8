{
  LOGGER.info("Starting up GitDataStore " + this);
  DataStoreTemplate template=runtimeProperties.get().removeRuntimeAttribute(DataStoreTemplate.class);
  if (template != null) {
    Ref rootTag=getGit().getRepository().getRef(GitHelpers.ROOT_TAG);
    if (rootTag == null) {
      getGit().commit().setMessage("First Commit").setCommitter("fabric","user@fabric").call();
      getGit().tag().setName(GitHelpers.ROOT_TAG).setMessage("Tag the root commit").call();
    }
    LOGGER.debug("Running datastore bootstrap template: " + template);
    template.doWith(this,dataStore.get());
  }
  GitProxyService proxyService=gitProxyService.get();
  defaultProxySelector=ProxySelector.getDefault();
  ProxySelector fabricProxySelector=new FabricGitLocalHostProxySelector(defaultProxySelector,proxyService);
  ProxySelector.setDefault(fabricProxySelector);
  LOGGER.debug("Setting up FabricProxySelector: {}",fabricProxySelector);
  if (gitRemoteUrl != null) {
    gitListener.runRemoteUrlChanged(gitRemoteUrl);
    remoteUrl=gitRemoteUrl;
  }
 else {
    gitService.get().addGitListener(gitListener);
    remoteUrl=gitService.get().getRemoteUrl();
    if (remoteUrl != null) {
      gitListener.runRemoteUrlChanged(remoteUrl);
    }
  }
  getInitialVersions();
  if (gitRemoteUrl != null) {
    LOGGER.info("Starting to pull from remote git repository every {} millis",gitRemotePollInterval);
    threadPool.scheduleWithFixedDelay(new Runnable(){
      @Override public void run(){
        LockHandle writeLock=aquireWriteLock();
        try {
          LOGGER.trace("Performing timed pull");
          doPullInternal();
          LOGGER.debug("Performed timed pull from external git repo");
        }
 catch (        Throwable e) {
          LOGGER.debug("Error during performed timed pull/push due " + e.getMessage(),e);
          LOGGER.warn("Error during performed timed pull/push due " + e.getMessage() + ". This exception is ignored.");
        }
 finally {
          writeLock.unlock();
        }
      }
      @Override public String toString(){
        return "TimedPushTask";
      }
    }
,1000,gitRemotePollInterval,TimeUnit.MILLISECONDS);
  }
  LOGGER.info("Using ZooKeeper SharedCount to react when master git repo is changed, so we can do a git pull to the local git repo.");
  counter=new SharedCount(curator.get(),ZkPath.GIT_TRIGGER.getPath(),0);
  counter.addListener(new SharedCountListener(){
    @Override public void countHasChanged(    final SharedCountReader sharedCountReader,    final int value) throws Exception {
      threadPool.submit(new Runnable(){
        @Override public void run(){
          LOGGER.debug("Watch counter updated to " + value + ", doing a pull");
          doPullInternal();
        }
      }
);
    }
    @Override public void stateChanged(    CuratorFramework curatorFramework,    ConnectionState connectionState){
switch (connectionState) {
case SUSPENDED:
case READ_ONLY:
case LOST:
        break;
case CONNECTED:
case RECONNECTED:
      LOGGER.info("Shared Counter (Re)connected, doing a pull");
    doPullInternal();
  break;
}
}
}
);
try {
counter.start();
}
 catch (KeeperException.NotReadOnlyException ex) {
}
doPullInternal();
}
