{
  LOGGER.info("Starting up GitDataStore " + this);
  DataStoreTemplate template=runtimeProperties.get().removeRuntimeAttribute(DataStoreTemplate.class);
  if (template != null) {
    LOGGER.debug("Using template: " + template);
    template.doWith(this,dataStore.get());
  }
  GitProxyService proxyService=gitProxyService.get();
  defaultProxySelector=ProxySelector.getDefault();
  ProxySelector fabricProxySelector=new FabricGitLocalHostProxySelector(defaultProxySelector,proxyService);
  ProxySelector.setDefault(fabricProxySelector);
  LOGGER.debug("Setting up FabricProxySelector: {}",fabricProxySelector);
  if (configuredUrl != null) {
    gitListener.runRemoteUrlChanged(configuredUrl);
    remoteUrl=configuredUrl;
  }
 else {
    gitService.get().addGitListener(gitListener);
    remoteUrl=gitService.get().getRemoteUrl();
    if (remoteUrl != null) {
      gitListener.runRemoteUrlChanged(remoteUrl);
    }
  }
  LockHandle writeLock=aquireWriteLock();
  try {
    getInitialVersions();
    Path homePath=runtimeProperties.get().getHomePath();
    Path fromPath=homePath.resolve(importDir);
    importExportHandler.initialImportFromPath(fromPath);
  }
  finally {
    writeLock.unlock();
  }
  LOGGER.info("Starting to push to remote git repository every {} millis",gitPushInterval);
  threadPool.scheduleWithFixedDelay(new Runnable(){
    @Override public void run(){
      LockHandle writeLock=aquireWriteLock();
      try {
        if (!initialPull.compareAndSet(false,true)) {
          LOGGER.trace("Performing initial pull");
          initialPull.set(pull());
          LOGGER.info("Initial pull completed with " + (initialPull.get() ? "success" : "failure"));
        }
        if (gitPullOnPush) {
          LOGGER.trace("Performing timed pull");
          pull();
          LOGGER.debug("Performed timed pull done");
        }
        LOGGER.trace("Performing timed push");
        push();
        LOGGER.debug("Performed timed push done");
      }
 catch (      Throwable e) {
        LOGGER.debug("Error during performed timed pull/push due " + e.getMessage(),e);
        LOGGER.warn("Error during performed timed pull/push due " + e.getMessage() + ". This exception is ignored.");
      }
 finally {
        writeLock.unlock();
      }
    }
    @Override public String toString(){
      return "TimedPushTask";
    }
  }
,1000,gitPushInterval,TimeUnit.MILLISECONDS);
  if (!gitPullOnPush) {
    LOGGER.info("Using ZooKeeper SharedCount to react when master git repo is changed, so we can do a git pull to the local git repo.");
    counter=new SharedCount(curator.get(),ZkPath.GIT_TRIGGER.getPath(),0);
    counter.addListener(new SharedCountListener(){
      @Override public void countHasChanged(      SharedCountReader sharedCountReader,      int value) throws Exception {
        Thread.sleep(1000);
        LOGGER.info("Watch counter updated to " + value + ", doing a pull");
        LockHandle writeLock=aquireWriteLock();
        try {
          pull();
        }
 catch (        Throwable e) {
          LOGGER.debug("Error during pull due " + e.getMessage(),e);
          LOGGER.warn("Error during pull due " + e.getMessage() + ". This exception is ignored.");
        }
 finally {
          writeLock.unlock();
        }
      }
      @Override public void stateChanged(      CuratorFramework curatorFramework,      ConnectionState connectionState){
      }
    }
);
    counter.start();
  }
}
