{
  assertWriteLock();
  StoredConfig config=git.getRepository().getConfig();
  String remoteUrl=config.getString("remote",remoteRef.get(),"url");
  if (remoteUrl == null) {
    LOGGER.info("No remote repository defined, so not doing a push");
    return false;
  }
  LOGGER.info("Pushing last change to: {}",remoteUrl);
  int retries=5;
  Iterator<PushResult> resit=null;
  TransportException lastPushException=null;
  List<RemoteRefUpdate> rejectedUpdates=new ArrayList<>();
  while (resit == null && retries-- > 0) {
    try {
      resit=git.push().setTimeout(gitTimeout).setCredentialsProvider(credentialsProvider).setPushAll().call().iterator();
      lastPushException=null;
    }
 catch (    TransportException ex) {
      lastPushException=ex;
      Thread.sleep(1000L);
    }
  }
  while (resit != null && resit.hasNext()) {
    PushResult pushResult=resit.next();
    if (results != null) {
      results.add(pushResult);
    }
    for (    RemoteRefUpdate refUpdate : pushResult.getRemoteUpdates()) {
      LOGGER.info("Remote ref update: {}" + refUpdate);
      Status status=refUpdate.getStatus();
      if (status != Status.OK && status != Status.UP_TO_DATE) {
        rejectedUpdates.add(refUpdate);
      }
    }
  }
  if (lastPushException != null || !rejectedUpdates.isEmpty()) {
    String checkoutId=context.getCheckoutId();
    if (checkoutId != null) {
      String branch=GitHelpers.currentBranch(git);
      RevCommit commit=CommitUtils.getCommit(git.getRepository(),checkoutId);
      LOGGER.warn("Resetting branch '{}' to: {}",branch,commit);
      git.reset().setMode(ResetType.HARD).setRef(checkoutId).call();
    }
    if (!rejectedUpdates.isEmpty()) {
      throw new IllegalStateException("Cannot fast forward, remote repository has already changed.");
    }
 else {
      throw new IllegalStateException("Cannot push last profile update.",lastPushException);
    }
  }
  return false;
}
