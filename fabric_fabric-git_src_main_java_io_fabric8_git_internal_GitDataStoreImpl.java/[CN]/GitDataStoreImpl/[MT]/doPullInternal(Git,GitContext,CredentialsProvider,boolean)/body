{
  assertWriteLock();
  try {
    Repository repository=git.getRepository();
    StoredConfig config=repository.getConfig();
    String url=config.getString("remote",remoteRef.get(),"url");
    if (url == null) {
      LOGGER.info("No remote repository defined, so not doing a pull");
      return false;
    }
    LOGGER.info("Performing a pull on remote URL: {}",url);
    try {
      git.fetch().setTimeout(gitTimeout).setCredentialsProvider(credentialsProvider).setRemote(remoteRef.get()).call();
      lastFetchWarning=null;
    }
 catch (    Exception ex) {
      String fetchWarning=ex.getMessage();
      if (!fetchWarning.equals(lastFetchWarning)) {
        LOGGER.warn("Fetch failed because of: " + fetchWarning);
        LOGGER.info("Fetch failed - the error will be ignored",ex);
        lastFetchWarning=fetchWarning;
      }
      return false;
    }
    Map<String,Ref> localBranches=new HashMap<String,Ref>();
    Map<String,Ref> remoteBranches=new HashMap<String,Ref>();
    Set<String> gitVersions=new HashSet<String>();
    for (    Ref ref : git.branchList().setListMode(ListBranchCommand.ListMode.ALL).call()) {
      if (ref.getName().startsWith("refs/remotes/" + remoteRef.get() + "/")) {
        String name=ref.getName().substring(("refs/remotes/" + remoteRef.get() + "/").length());
        remoteBranches.put(name,ref);
        gitVersions.add(name);
      }
 else       if (ref.getName().startsWith("refs/heads/")) {
        String name=ref.getName().substring(("refs/heads/").length());
        localBranches.put(name,ref);
        gitVersions.add(name);
      }
    }
    boolean hasChanged=false;
    if (!remoteBranches.isEmpty()) {
      for (      String version : gitVersions) {
        if (!remoteBranches.containsKey(version)) {
          if (doDeleteBranches && !version.equals(MASTER_BRANCH)) {
            try {
              git.branchDelete().setBranchNames(localBranches.get(version).getName()).setForce(true).call();
            }
 catch (            CannotDeleteCurrentBranchException ex) {
              git.checkout().setName(MASTER_BRANCH).setForce(true).call();
              git.branchDelete().setBranchNames(localBranches.get(version).getName()).setForce(true).call();
            }
            removeVersionFromCaches(version);
            hasChanged=true;
          }
        }
 else         if (!localBranches.containsKey(version)) {
          cacheVersionId(version);
          git.checkout().setCreateBranch(true).setName(version).setStartPoint(remoteRef.get() + "/" + version).setUpstreamMode(CreateBranchCommand.SetupUpstreamMode.TRACK).setForce(true).call();
          hasChanged=true;
        }
 else {
          String localCommit=localBranches.get(version).getObjectId().getName();
          String remoteCommit=remoteBranches.get(version).getObjectId().getName();
          if (!localCommit.equals(remoteCommit)) {
            git.clean().setCleanDirectories(true).call();
            git.checkout().setName("HEAD").setForce(true).call();
            git.checkout().setName(version).setForce(true).call();
            MergeResult result=git.merge().setFastForward(FastForwardMode.FF_ONLY).include(remoteBranches.get(version).getObjectId()).call();
            hasChanged=result.getMergeStatus() != MergeResult.MergeStatus.ALREADY_UP_TO_DATE && hasChanged(git,localCommit,remoteCommit);
          }
        }
      }
    }
    pullCount.incrementAndGet();
    if (hasChanged) {
      LOGGER.info("Changed after pull!");
      LOGGER.debug("Called from ...",new RuntimeException());
      return true;
    }
 else {
      LOGGER.info("No change after pull!");
      return false;
    }
  }
 catch (  Throwable ex) {
    LOGGER.debug("Failed to pull from the remote git repo " + GitHelpers.getRootGitDirectory(git),ex);
    LOGGER.warn("Failed to pull from the remote git repo " + GitHelpers.getRootGitDirectory(git) + " due "+ ex.getMessage()+ ". This exception is ignored.");
    return false;
  }
}
