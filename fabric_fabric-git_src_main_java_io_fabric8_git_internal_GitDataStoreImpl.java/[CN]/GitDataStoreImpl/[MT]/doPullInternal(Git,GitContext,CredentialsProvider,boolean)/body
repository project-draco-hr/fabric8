{
  assertWriteLock();
  IllegalStateAssertion.assertTrue(context.incrementPullCount(),"Pull not required in context");
  IllegalStateAssertion.assertTrue(isPullAllowedInThreadContext(),"Pull not not allowed in thread context");
  try {
    Repository repository=git.getRepository();
    StoredConfig config=repository.getConfig();
    String url=config.getString("remote",remoteRef.get(),"url");
    if (Strings.isNullOrBlank(url)) {
      LOGGER.info("No remote repository defined for the git repository at {} so not doing a pull",GitHelpers.getRootGitDirectory(git));
      return false;
    }
    LOGGER.info("Performing a pull git repository {} on remote URL: {}",GitHelpers.getRootGitDirectory(git),url);
    git.reset().setMode(ResetType.HARD).call();
    try {
      git.fetch().setTimeout(gitTimeout).setCredentialsProvider(credentialsProvider).setRemote(remoteRef.get()).call();
      lastFetchWarning=null;
    }
 catch (    Exception ex) {
      String fetchWarning=ex.getMessage();
      if (!fetchWarning.equals(lastFetchWarning)) {
        LOGGER.warn("Fetch failed because of: " + fetchWarning);
        LOGGER.info("Fetch failed - the error will be ignored",ex);
        lastFetchWarning=fetchWarning;
      }
      return false;
    }
    Map<String,Ref> localBranches=new HashMap<String,Ref>();
    Map<String,Ref> remoteBranches=new HashMap<String,Ref>();
    Set<String> gitVersions=new HashSet<String>();
    for (    Ref ref : git.branchList().setListMode(ListBranchCommand.ListMode.ALL).call()) {
      if (ref.getName().startsWith("refs/remotes/" + remoteRef.get() + "/")) {
        String name=ref.getName().substring(("refs/remotes/" + remoteRef.get() + "/").length());
        remoteBranches.put(name,ref);
        gitVersions.add(name);
      }
 else       if (ref.getName().startsWith("refs/heads/")) {
        String name=ref.getName().substring(("refs/heads/").length());
        localBranches.put(name,ref);
        gitVersions.add(name);
      }
    }
    boolean hasChanged=false;
    for (    String version : gitVersions) {
      if (remoteBranches.isEmpty()) {
      }
 else       if (!remoteBranches.containsKey(version)) {
        if (doDeleteBranches && !version.equals(MASTER_BRANCH)) {
          try {
            git.branchDelete().setBranchNames(localBranches.get(version).getName()).setForce(true).call();
          }
 catch (          CannotDeleteCurrentBranchException ex) {
            git.checkout().setName(MASTER_BRANCH).setForce(true).call();
            git.branchDelete().setBranchNames(localBranches.get(version).getName()).setForce(true).call();
          }
          removeVersionFromCaches(version);
          hasChanged=true;
        }
      }
 else       if (!localBranches.containsKey(version)) {
        cacheVersionId(version);
        git.checkout().setCreateBranch(true).setName(version).setStartPoint(remoteRef.get() + "/" + version).setUpstreamMode(CreateBranchCommand.SetupUpstreamMode.TRACK).setForce(true).call();
        hasChanged=true;
      }
 else {
        String localCommit=localBranches.get(version).getObjectId().getName();
        String remoteCommit=remoteBranches.get(version).getObjectId().getName();
        if (!localCommit.equals(remoteCommit)) {
          git.clean().setCleanDirectories(true).call();
          git.checkout().setName("HEAD").setForce(true).call();
          git.checkout().setName(version).setForce(true).call();
          MergeResult result=git.merge().setStrategy(MergeStrategy.THEIRS).include(remoteBranches.get(version).getObjectId()).call();
          if (result.getMergeStatus() != MergeResult.MergeStatus.ALREADY_UP_TO_DATE && hasChanged(git,localCommit,remoteCommit)) {
            hasChanged=true;
          }
        }
      }
    }
    pullCount.incrementAndGet();
    if (hasChanged) {
      LOGGER.info("Changed after pull!");
      LOGGER.debug("Called from ...",new RuntimeException());
      if (credentialsProvider != null) {
        GitHelpers.getProfilesDirectory(git);
      }
      return true;
    }
 else {
      LOGGER.debug("No change after pull!");
      return false;
    }
  }
 catch (  Throwable ex) {
    LOGGER.debug("Failed to pull from the remote git repo " + GitHelpers.getRootGitDirectory(git),ex);
    LOGGER.warn("Failed to pull from the remote git repo " + GitHelpers.getRootGitDirectory(git) + " due "+ ex.getMessage()+ ". This exception is ignored.");
    return false;
  }
 finally {
    pullAllowedAssociation.set(Boolean.FALSE);
  }
}
