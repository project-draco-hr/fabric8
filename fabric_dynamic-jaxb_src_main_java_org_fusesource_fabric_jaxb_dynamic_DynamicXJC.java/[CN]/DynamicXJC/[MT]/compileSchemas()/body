{
  SchemaCompiler compiler=createSchemaCompiler();
  String stem=toString() + "-" + System.currentTimeMillis();
  File src=new File(tmpdir,stem + "-src");
  if (!src.mkdir()) {
    throw new IllegalStateException("Unable to create working directory " + src.getPath());
  }
  boolean first=true;
  StringBuilder sb=new StringBuilder();
  for (  String rawUrl : getSchemaUrls()) {
    String schemaUrl=resolveUrl(rawUrl);
    InnerErrorListener listener=new InnerErrorListener(schemaUrl);
    Object elForRun=ReflectionInvokationHandler.createProxyWrapper(listener,JAXBUtils.getParamClass(compiler,"setErrorListener"));
    compiler.setErrorListener(elForRun);
    compiler.parseSchema(new InputSource(schemaUrl));
    S2JJAXBModel intermediateModel=compiler.bind();
    listener.throwException();
    JCodeModel codeModel=intermediateModel.generateCode(null,elForRun);
    for (Iterator<JPackage> packages=codeModel.packages(); packages.hasNext(); ) {
      JPackage jpackage=packages.next();
      if (!isValidPackage(jpackage)) {
        continue;
      }
      if (first) {
        first=false;
      }
 else {
        sb.append(':');
      }
      sb.append(jpackage.name());
    }
    JAXBUtils.logGeneratedClassNames(LOG,codeModel);
    try {
      Object writer=JAXBUtils.createFileCodeWriter(src);
      codeModel.build(writer);
    }
 catch (    Exception e) {
      throw new IllegalStateException("Unable to write generated Java files for schemas: " + e.getMessage(),e);
    }
  }
  String packageList=sb.toString();
  File classes=new File(tmpdir,stem + "-classes");
  if (!classes.mkdir()) {
    throw new IllegalStateException("Unable to create working directory " + classes.getPath());
  }
  StringBuilder classPath=new StringBuilder();
  try {
    setupClasspath(classPath,classLoader);
  }
 catch (  Exception ex) {
    throw new RuntimeException(ex);
  }
  List<File> srcFiles=FileUtils.getFilesRecurse(src,".+\\.java$");
  if (!compileJavaSrc(classPath.toString(),srcFiles,classes.toString())) {
    LOG.log(Level.SEVERE,new Message("COULD_NOT_COMPILE_SRC",LOG,getSchemaUrls().toString()).toString());
  }
  FileUtils.removeDir(src);
  URL[] urls;
  try {
    urls=new URL[]{classes.toURI().toURL()};
  }
 catch (  MalformedURLException mue) {
    throw new IllegalStateException("Internal error; a directory returns a malformed URL: " + mue.getMessage(),mue);
  }
  ClassLoader cl=ClassLoaderUtils.getURLClassLoader(urls,classLoader);
  JAXBContext context;
  Map<String,Object> contextProperties=jaxbContextProperties;
  if (contextProperties == null) {
    contextProperties=Collections.emptyMap();
  }
  try {
    if (StringUtils.isEmpty(packageList)) {
      context=JAXBContext.newInstance(new Class[0],contextProperties);
    }
 else {
      context=JAXBContext.newInstance(packageList,cl,contextProperties);
    }
  }
 catch (  JAXBException jbe) {
    throw new IllegalStateException("Unable to create JAXBContext for generated packages: " + jbe.getMessage(),jbe);
  }
  classes.deleteOnExit();
  return new CompileResults(cl,context);
}
