{
  final List<Patch> patches=new ArrayList<Patch>();
  for (  String id : ids) {
    Patch patch=getPatch(id);
    if (patch == null) {
      throw new IllegalArgumentException("Unknown patch: " + id);
    }
    patches.add(patch);
  }
  try {
    final Set<Bundle> toDelete=new HashSet<Bundle>();
    final Map<String,String> toInstall=new HashMap<String,String>();
    final List<BundleUpdate> updates=new ArrayList<BundleUpdate>();
    Bundle[] allBundles=bundleContext.getBundles();
    for (    Patch patch : patches) {
      System.out.println("Installing patch: " + patch.getId());
      for (      String url : patch.getBundles()) {
        JarInputStream jis=new JarInputStream(new URL(url).openStream());
        Attributes att=jis.getManifest().getMainAttributes();
        jis.close();
        String sn=att.getValue(Constants.BUNDLE_SYMBOLICNAME);
        if (sn == null) {
          continue;
        }
        if (sn.contains(";")) {
          sn=sn.substring(0,sn.indexOf(";"));
        }
        String vr=att.getValue(Constants.BUNDLE_VERSION);
        Version v=VersionTable.getVersion(vr);
        System.out.println("Checking update " + sn + "/"+ v.toString());
        Version lower=new Version(v.getMajor(),v.getMinor(),0);
        if (v.compareTo(lower) > 0) {
          VersionRange range=new VersionRange(false,lower,v,true);
          boolean overwrittenUpdate=false;
          for (          BundleUpdate update : updates) {
            if (sn.equals(update.getSymbolicName())) {
              System.out.println("    Found previous update: " + update.getSymbolicName() + "/"+ update.getNewVersion());
              Version n=VersionTable.getVersion(update.getNewVersion());
              if (v.compareTo(n) > 0) {
                System.out.println("    Updating update to: " + sn + "/"+ v.toString());
                updates.remove(update);
                toInstall.remove(sn + "/" + update.getNewVersion());
                updates.add(new BundleUpdateImpl(sn,v.toString(),update.getPreviousVersion(),update.getPreviousLocation()));
                toInstall.put(sn + "/" + v.toString(),url);
                overwrittenUpdate=true;
                break;
              }
 else {
                System.out.println("    Ignoring older bundle update");
              }
            }
          }
          if (!overwrittenUpdate) {
            for (            Bundle bundle : allBundles) {
              if (bundle.getBundleId() != 0 && sn.equals(bundle.getSymbolicName())) {
                Version oldV=bundle.getVersion();
                System.out.println("    Found matching bundle: " + sn + "/"+ oldV.toString());
                if (range.contains(oldV)) {
                  String location=bundle.getLocation();
                  updates.add(new BundleUpdateImpl(sn,v.toString(),oldV.toString(),location));
                  toInstall.put(sn + "/" + v.toString(),url);
                  toDelete.add(bundle);
                  System.out.println("    Updating bundle to: " + sn + "/"+ v.toString());
                }
 else {
                  System.out.println("    Ignoring older bundle update");
                }
              }
            }
          }
        }
      }
    }
    System.out.println("Bundles to delete:");
    for (    Bundle b : toDelete) {
      System.out.println("    " + b.getSymbolicName() + "/"+ b.getVersion().toString());
    }
    System.out.println("Bundles to install:");
    for (    String b : toInstall.keySet()) {
      System.out.println("    " + b);
    }
    System.out.println("Installation will begin.  The connection may be lost or the console restarted.");
    System.out.flush();
    new Thread(){
      public void run(){
        try {
          applyChanges(toDelete,toInstall.values());
          System.out.println("Patches installed successfully.");
          System.out.flush();
        }
 catch (        Exception e) {
          e.printStackTrace(System.err);
          System.err.flush();
        }
      }
    }
.start();
  }
 catch (  Exception e) {
    e.printStackTrace(System.err);
    System.err.flush();
  }
}
