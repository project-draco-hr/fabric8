{
  boolean reschedule=true;
  try {
    Settings settings=IndicesManagementService.this.settings.getByPrefix("insight.indices.management.");
    Set<String> repositories=settings.getByPrefix("repository.").getAsStructuredMap().keySet();
    int opened=settings.getAsInt("opened",7);
    int closed=settings.getAsInt("closed",14);
    int stored=settings.getAsInt("stored",0);
    Set<String> toOptimize=new HashSet<>();
    Set<String> toStore=new HashSet<>();
    Set<String> toClose=new HashSet<>();
    Set<String> toDelete=new HashSet<>();
    AdminClient adminClient=injector.getInstance(AdminClient.class);
    ClusterAdminClient clusterAdminClient=adminClient.cluster();
    IndicesAdminClient indicesAdminClient=adminClient.indices();
    ClusterStateResponse state=clusterAdminClient.state(clusterAdminClient.prepareState().request()).actionGet();
    String masterNodeId=state.getState().nodes().masterNodeId();
    String localNodeId=state.getState().nodes().getLocalNodeId();
    if (localNodeId == null || !localNodeId.equals(masterNodeId)) {
      return;
    }
    LocalDate now=new LocalDate();
    Pattern pattern=Pattern.compile(".*-([0-9]{4})\\.([0-9]{2})\\.([0-9]{2})");
    for (    ObjectObjectCursor<String,IndexMetaData> it : state.getState().metaData().indices()) {
      String index=it.value.getIndex();
      Matcher matcher=pattern.matcher(index);
      if (matcher.find()) {
        LocalDate date=new LocalDate(Integer.parseInt(matcher.group(1)),Integer.parseInt(matcher.group(2)),Integer.parseInt(matcher.group(3)));
        int days=Days.daysBetween(date,now).getDays();
        if (days > 0) {
          toOptimize.add(index);
          if (stored < 0 || days <= stored) {
            toStore.add(index);
          }
          if (opened >= 0 && days > opened) {
            if (closed < 0 || days <= closed) {
              toClose.add(index);
            }
 else {
              toDelete.add(index);
            }
          }
        }
      }
 else {
        logger.warn("Index name {} does not match the supported pattern");
      }
    }
    if (!toOptimize.isEmpty()) {
      logger.info("Optimizing indices " + toOptimize);
      String[] indices=toOptimize.toArray(new String[toOptimize.size()]);
      OptimizeRequest request=indicesAdminClient.prepareOptimize(indices).setMaxNumSegments(1).request();
      indicesAdminClient.optimize(request).actionGet();
    }
    if (!toStore.isEmpty()) {
      if (repositories.isEmpty()) {
        logger.error("No repository defined for storing indices");
        return;
      }
      RepositoriesMetaData repositoriesMetaData=(RepositoriesMetaData)state.getState().getMetaData().getCustoms().get("repositories");
      logger.info("Storing indices " + toStore);
      for (      String repository : repositories) {
        RepositoryMetaData repositoryMetaData=null;
        for (        RepositoryMetaData rmd : repositoriesMetaData.repositories()) {
          if (repository.equals(rmd.name())) {
            repositoryMetaData=rmd;
            break;
          }
        }
        Settings repoSettings=settings.getByPrefix("repository." + repository + ".");
        String type=repoSettings.get("type");
        Settings set=repoSettings.getByPrefix("settings.");
        if (type != null && set != null) {
          if (repositoryMetaData == null || !type.equals(repositoryMetaData.type()) || !set.getAsMap().equals(repositoryMetaData.settings().getAsMap())) {
            logger.info("Updating repository definition for " + repository);
            PutRepositoryRequest req=clusterAdminClient.preparePutRepository(repository).setType(type).setSettings(repoSettings.getByPrefix("settings.")).request();
            clusterAdminClient.putRepository(req).actionGet();
          }
        }
 else {
          if (repositoryMetaData == null) {
            logger.warn("Repository " + repository + " is not defined");
            continue;
          }
        }
        GetSnapshotsResponse snapshots=clusterAdminClient.getSnapshots(clusterAdminClient.prepareGetSnapshots(repository).request()).actionGet();
        Map<String,SnapshotInfo> infos=new HashMap<>();
        for (        SnapshotInfo info : snapshots.getSnapshots()) {
          infos.put(info.name(),info);
        }
        for (        String index : toStore) {
          SnapshotInfo info=infos.get(index);
          if (info != null) {
            if (info.endTime() == 0L) {
              continue;
            }
            if (info.failedShards() > 0) {
              DeleteSnapshotRequest req=clusterAdminClient.prepareDeleteSnapshot(repository,index).request();
              clusterAdminClient.deleteSnapshot(req).actionGet();
              info=null;
            }
          }
          if (info == null) {
            CreateSnapshotRequest req=clusterAdminClient.prepareCreateSnapshot(repository,index).setIncludeGlobalState(false).setIndices(index).setWaitForCompletion(true).request();
            clusterAdminClient.createSnapshot(req).actionGet();
          }
        }
      }
    }
    if (!toClose.isEmpty()) {
      logger.info("Closing indices " + toClose);
      String[] indices=toClose.toArray(new String[toClose.size()]);
      CloseIndexRequest req=indicesAdminClient.prepareClose(indices).request();
      indicesAdminClient.close(req).actionGet();
    }
    if (!toDelete.isEmpty()) {
      logger.info("Deleting indices " + toDelete);
      String[] indices=toDelete.toArray(new String[toDelete.size()]);
      DeleteIndexRequest req=indicesAdminClient.prepareDelete(indices).request();
      indicesAdminClient.delete(req).actionGet();
    }
  }
 catch (  ElasticsearchException e) {
    if (e.getCause() instanceof InterruptedException) {
      reschedule=true;
    }
 else {
      logger.error("Error performing indices management",e);
    }
  }
 finally {
    if (reschedule) {
      TimeValue interval=TimeValue.parseTimeValue(settings.get("interval"),TimeValue.timeValueHours(8));
      future=threadPool.schedule(interval,ThreadPool.Names.GENERIC,this);
    }
  }
}
