{
  NullArgumentException.validateNotNull(jarInputStream,"Jar URL");
  NullArgumentException.validateNotNull(instructions,"Instructions");
  NullArgumentException.validateNotEmpty(jarInfo,"Jar info");
  LOG.debug("Creating bundle for [" + jarInfo + "]");
  LOG.debug("Overwrite mode: " + overwriteMode);
  LOG.trace("Using instructions " + instructions);
  final Jar jar=new Jar("dot",jarInputStream);
  final Manifest manifest=jar.getManifest();
  if (manifest == null || OverwriteMode.KEEP != overwriteMode || (manifest.getMainAttributes().getValue(Analyzer.EXPORT_PACKAGE) == null && manifest.getMainAttributes().getValue(Analyzer.IMPORT_PACKAGE) == null)) {
    final Properties properties=new Properties();
    properties.putAll(instructions);
    properties.put("Generated-By-FAB-From",jarInfo);
    final Analyzer analyzer=new Analyzer();
    analyzer.setJar(jar);
    analyzer.setProperties(properties);
    for (    Map.Entry<String,Object> entry : embeddedResources.entrySet()) {
      String path=entry.getKey();
      Object value=entry.getValue();
      Resource resource=toResource(value);
      if (resource != null) {
        jar.putResource(path,resource);
        try {
          File file=toFile(value);
          analyzer.addClasspath(file);
        }
 catch (        IOException e) {
          LOG.warn("Failed to get File for " + value + ". "+ e,e);
        }
      }
    }
    if (manifest != null && OverwriteMode.MERGE == overwriteMode) {
      analyzer.mergeManifest(manifest);
    }
    checkMandatoryProperties(analyzer,jar,jarInfo);
    analyzer.calcManifest();
    Attributes main=jar.getManifest().getMainAttributes();
    String importPackages=emptyIfNull(main.getValue(Analyzer.IMPORT_PACKAGE));
    Map<String,Map<String,String>> values=new Analyzer().parseHeader(importPackages);
    if (versionResolver != null) {
      for (      Map.Entry<String,Map<String,String>> entry : values.entrySet()) {
        String packageName=entry.getKey();
        Map<String,String> packageValues=entry.getValue();
        if (!packageValues.containsKey("version")) {
          String version=versionResolver.resolvePackageVersion(packageName);
          if (version != null) {
            packageValues.put("version",version);
          }
        }
      }
    }
    for (    Map.Entry<String,Map<String,String>> entry : extraImportPackages.entrySet()) {
      Map<String,String> original=values.get(entry.getKey());
      if (original == null) {
        original=entry.getValue();
      }
 else {
        original.putAll(entry.getValue());
      }
      values.put(entry.getKey(),original);
    }
    String excludedPackagesText=main.getValue(ServiceConstants.INSTR_FAB_EXCLUDE_IMPORTS_PACKAGE);
    if (notEmpty(excludedPackagesText)) {
      StringTokenizer e=new StringTokenizer(excludedPackagesText);
      while (e.hasMoreTokens()) {
        String expression=e.nextToken();
        String ignore=expression;
        if (ignore.endsWith("*")) {
          do {
            ignore=ignore.substring(0,ignore.length() - 1);
          }
 while (ignore.endsWith("*"));
          if (ignore.length() == 0) {
            LOG.debug("Ignoring all imports due to %s value of %s",ServiceConstants.INSTR_FAB_EXCLUDE_IMPORTS_PACKAGE,expression);
            values.clear();
          }
 else {
            List<String> packageNames=new ArrayList<String>(values.keySet());
            for (            String packageName : packageNames) {
              if (packageName.equals(ignore) || packageName.startsWith(ignore)) {
                if (LOG.isDebugEnabled()) {
                  LOG.debug("Ignoring package " + packageName + " due to "+ ServiceConstants.INSTR_FAB_EXCLUDE_IMPORTS_PACKAGE+ " value of "+ expression);
                }
                values.remove(packageName);
              }
            }
          }
        }
 else {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Ignoring package " + ignore + " due to "+ ServiceConstants.INSTR_FAB_EXCLUDE_IMPORTS_PACKAGE+ " header");
          }
          values.remove(ignore);
        }
      }
    }
    for (    Map.Entry<String,Map<String,String>> entry : values.entrySet()) {
      String packageName=entry.getKey();
      Map<String,String> map=entry.getValue();
      String res=map.get("resolution:");
      if ("optional".equals(res)) {
        if (!versionResolver.isPackageOptional(packageName)) {
          map.remove("resolution:");
          res=null;
        }
      }
      if (!"optional".equals(res)) {
        actualImports.add(packageName);
      }
    }
    importPackages=Processor.printClauses(values,ALLOWED_PACKAGE_CLAUSES);
    if (notEmpty(importPackages)) {
      main.putValue(Analyzer.IMPORT_PACKAGE,importPackages);
    }
    String exportPackages=emptyIfNull(main.getValue(Analyzer.EXPORT_PACKAGE));
    Map<String,Map<String,String>> exports=new Analyzer().parseHeader(exportPackages);
    for (    Map.Entry<String,Map<String,String>> entry : exports.entrySet()) {
      String packageName=entry.getKey();
      Map<String,String> map=entry.getValue();
      String version=map.get("version");
      if (version == null) {
        version=versionResolver.resolveExportPackageVersion(packageName);
        if (version != null) {
          map.put("version",version);
        }
      }
    }
    exportPackages=Processor.printClauses(exports,ALLOWED_PACKAGE_CLAUSES);
    if (notEmpty(exportPackages)) {
      main.putValue(Analyzer.EXPORT_PACKAGE,exportPackages);
    }
  }
  return jar;
}
