{
  PomDetails pomDetails=connection.resolvePomDetails();
  if (!pomDetails.isValid()) {
    LOG.warn("Cannot resolve pom.xml for " + connection.getJarFile());
    return;
  }
  DependencyTreeResult result=resolver.collectDependencies(pomDetails,offline);
  this.rootTree=result.getTree();
  String sharedFilterText=getManfiestProperty(ServiceConstants.INSTR_FAB_PROVIDED_DEPENDENCY);
  String requireBundleFilterText=getManfiestProperty(ServiceConstants.INSTR_FAB_DEPENDENCY_REQUIRE_BUNDLE);
  String excludeFilterText=getManfiestProperty(ServiceConstants.INSTR_FAB_EXCLUDE_DEPENDENCY);
  String optionalDependencyText=getManfiestProperty(ServiceConstants.INSTR_FAB_OPTIONAL_DEPENDENCY);
  sharedFilter=DependencyTreeFilters.parseShareFilter(sharedFilterText);
  requireBundleFilter=DependencyTreeFilters.parseRequireBundleFilter(requireBundleFilterText);
  excludePackageFilter=DependencyTreeFilters.parseExcludeFilter(excludeFilterText);
  excludeOptionalFilter=DependencyTreeFilters.parseExcludeOptionalFilter(optionalDependencyText);
  bundleClassPath.addAll(Strings.splitAsList(getManfiestProperty(ServiceConstants.INSTR_BUNDLE_CLASSPATH),","));
  requireBundles.addAll(Strings.splitAsList(getManfiestProperty(ServiceConstants.INSTR_REQUIRE_BUNDLE),","));
  importPackages.addAll(Strings.splitAsList(getManfiestProperty(ServiceConstants.INSTR_IMPORT_PACKAGE),","));
  String name=getManfiestProperty(ServiceConstants.INSTR_BUNDLE_SYMBOLIC_NAME);
  if (name.length() <= 0) {
    name=rootTree.getBundleSymbolicName();
    instructions.setProperty(ServiceConstants.INSTR_BUNDLE_SYMBOLIC_NAME,name);
  }
  LOG.debug("Resolving Dependencies for: " + rootTree.getDependencyId());
  addDependencies(rootTree);
  Model model=pomDetails.getModel();
  moduleId=new VersionedDependencyId(model);
  ModuleRegistry.VersionedModule module=moduleRegistry.getVersionedModule(moduleId);
  if (module == null || module.getFile() != null) {
    registerModule(model);
  }
  resolveExtensions(model,rootTree);
  for (  DependencyTree dependencyTree : sharedDependencies) {
    if (requireBundleFilter.matches(dependencyTree)) {
      String bundleId=dependencyTree.getBundleSymbolicName();
      Version version=new Version(VersionCleaner.clean(dependencyTree.getVersion()));
      requireBundles.add(bundleId + ";bundle-version=" + version+ "");
    }
 else {
      if (processImportPackages) {
        importAllExportedPackages(dependencyTree);
      }
    }
  }
  for (  DependencyTree dependencyTree : nonSharedDependencies) {
    if (dependencyTree.isValidLibrary()) {
      String url=dependencyTree.getUrl();
      if (url != null) {
        String path=dependencyTree.getGroupId() + "." + dependencyTree.getArtifactId()+ ".jar";
        if (!bundleClassPath.contains(path)) {
          File file=new File(url);
          if (file.exists()) {
            embeddedResources.put(path,file);
          }
 else {
            embeddedResources.put(path,new URL(url));
          }
          addBundleClassPath(path);
        }
      }
    }
  }
  nonSharedDependencies=filterOutDuplicates(nonSharedDependencies);
  sharedDependencies=filterOutDuplicates(sharedDependencies);
  installDependencies=filterOutDuplicates(installDependencies);
  optionalDependencies=filterOutDuplicates(optionalDependencies);
  LOG.debug("nonSharedDependencies:");
  for (  DependencyTree d : nonSharedDependencies) {
    LOG.debug("  " + d.getDependencyId());
  }
  LOG.debug("sharedDependencies:");
  for (  DependencyTree d : sharedDependencies) {
    LOG.debug("  " + d.getDependencyId());
  }
  LOG.debug("installDependencies:");
  for (  DependencyTree d : installDependencies) {
    LOG.debug("  " + d.getDependencyId());
  }
  LOG.debug("resolved: bundleClassPath: " + Strings.join(bundleClassPath,"\t\n"));
  LOG.debug("resolved: requireBundles: " + Strings.join(requireBundles,"\t\n"));
  LOG.debug("resolved: importPackages: " + Strings.join(importPackages,"\t\n"));
  instructions.setProperty(ServiceConstants.INSTR_BUNDLE_CLASSPATH,Strings.join(bundleClassPath,","));
  instructions.setProperty(ServiceConstants.INSTR_REQUIRE_BUNDLE,Strings.join(requireBundles,","));
  instructions.setProperty(ServiceConstants.INSTR_FAB_MODULE_ID,moduleId.toString());
}
