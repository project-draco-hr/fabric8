{
  PomDetails pomDetails=connection.resolvePomDetails();
  if (!pomDetails.isValid()) {
    LOG.warn("Cannot resolve pom.xml for " + connection.getJarFile());
    return;
  }
  DependencyTreeResult result=resolver.collectDependencies(pomDetails,offline);
  this.rootTree=result.getTree();
  sharedFilterPatterns.addAll(Strings.splitAndTrimAsList(emptyIfNull(getManfiestProperty(ServiceConstants.INSTR_FAB_PROVIDED_DEPENDENCY)),"\\s+"));
  requireBundleFilterPatterns.addAll(Strings.splitAndTrimAsList(emptyIfNull(getManfiestProperty(ServiceConstants.INSTR_FAB_DEPENDENCY_REQUIRE_BUNDLE)),"\\s+"));
  excludeFilterPatterns.addAll(Strings.splitAndTrimAsList(emptyIfNull(getManfiestProperty(ServiceConstants.INSTR_FAB_EXCLUDE_DEPENDENCY)),"\\s+"));
  optionalDependencyPatterns.addAll(Strings.splitAndTrimAsList(emptyIfNull(getManfiestProperty(ServiceConstants.INSTR_FAB_OPTIONAL_DEPENDENCY)),"\\s+"));
  sharedFilter=DependencyTreeFilters.parseShareFilter(join(sharedFilterPatterns," "));
  requireBundleFilter=DependencyTreeFilters.parseRequireBundleFilter(join(requireBundleFilterPatterns," "));
  excludePackageFilter=DependencyTreeFilters.parseExcludeFilter(join(excludeFilterPatterns," "));
  excludeOptionalFilter=DependencyTreeFilters.parseExcludeOptionalFilter(join(optionalDependencyPatterns," "));
  bundleClassPath.addAll(Strings.splitAsList(getManfiestProperty(ServiceConstants.INSTR_BUNDLE_CLASSPATH),","));
  requireBundles.addAll(Strings.splitAsList(getManfiestProperty(ServiceConstants.INSTR_REQUIRE_BUNDLE),","));
  importPackages.addAll(Strings.splitAsList(getManfiestProperty(ServiceConstants.INSTR_IMPORT_PACKAGE),","));
  String name=getManfiestProperty(ServiceConstants.INSTR_BUNDLE_SYMBOLIC_NAME);
  if (name.length() <= 0) {
    name=rootTree.getBundleSymbolicName();
    instructions.setProperty(ServiceConstants.INSTR_BUNDLE_SYMBOLIC_NAME,name);
  }
  LOG.debug("Resolving Dependencies for: " + rootTree.getDependencyId());
  addDependencies(rootTree);
  Model model=pomDetails.getModel();
  moduleId=new VersionedDependencyId(model);
  ModuleRegistry.VersionedModule module=moduleRegistry.getVersionedModule(moduleId);
  if (module == null || module.getFile() != null) {
    registerModule(model);
  }
  resolveExtensions(model,rootTree);
  for (  DependencyTree dependencyTree : sharedDependencies) {
    if (requireBundleFilter.matches(dependencyTree)) {
      String bundleId=dependencyTree.getBundleSymbolicName();
      Version version=new Version(VersionCleaner.clean(dependencyTree.getVersion()));
      requireBundles.add(bundleId + ";bundle-version=" + version+ "");
    }
 else {
      if (processImportPackages) {
        importAllExportedPackages(dependencyTree);
      }
    }
  }
  for (  DependencyTree dependencyTree : nonSharedDependencies) {
    if (dependencyTree.isValidLibrary()) {
      String url=dependencyTree.getUrl();
      if (url != null) {
        String path=dependencyTree.getGroupId() + "." + dependencyTree.getArtifactId()+ ".jar";
        if (!bundleClassPath.contains(path)) {
          File file=new File(url);
          if (file.exists()) {
            embeddedResources.put(path,file);
          }
 else {
            embeddedResources.put(path,new URL(url));
          }
          addBundleClassPath(path);
        }
      }
    }
  }
  nonSharedDependencies=filterOutDuplicates(nonSharedDependencies);
  sharedDependencies=filterOutDuplicates(sharedDependencies);
  installDependencies=filterOutDuplicates(installDependencies);
  optionalDependencies=filterOutDuplicates(optionalDependencies);
  LOG.debug("nonSharedDependencies:");
  for (  DependencyTree d : nonSharedDependencies) {
    LOG.debug("  " + d.getDependencyId());
  }
  LOG.debug("sharedDependencies:");
  for (  DependencyTree d : sharedDependencies) {
    LOG.debug("  " + d.getDependencyId());
  }
  LOG.debug("installDependencies:");
  for (  DependencyTree d : installDependencies) {
    LOG.debug("  " + d.getDependencyId());
  }
  LOG.debug("resolved: bundleClassPath: " + Strings.join(bundleClassPath,"\t\n"));
  LOG.debug("resolved: requireBundles: " + Strings.join(requireBundles,"\t\n"));
  LOG.debug("resolved: importPackages: " + Strings.join(importPackages,"\t\n"));
  instructions.setProperty(ServiceConstants.INSTR_BUNDLE_CLASSPATH,Strings.join(bundleClassPath,","));
  instructions.setProperty(ServiceConstants.INSTR_REQUIRE_BUNDLE,Strings.join(requireBundles,","));
  instructions.setProperty(ServiceConstants.INSTR_FAB_MODULE_ID,moduleId.toString());
  if (!sharedFilterPatterns.isEmpty()) {
    instructions.setProperty(ServiceConstants.INSTR_FAB_PROVIDED_DEPENDENCY,join(sharedFilterPatterns," "));
  }
  if (!requireBundleFilterPatterns.isEmpty()) {
    instructions.setProperty(ServiceConstants.INSTR_FAB_DEPENDENCY_REQUIRE_BUNDLE,join(requireBundleFilterPatterns," "));
  }
  if (!excludeFilterPatterns.isEmpty()) {
    instructions.setProperty(ServiceConstants.INSTR_FAB_EXCLUDE_DEPENDENCY,join(excludeFilterPatterns," "));
  }
  if (!optionalDependencyPatterns.isEmpty()) {
    instructions.setProperty(ServiceConstants.INSTR_FAB_OPTIONAL_DEPENDENCY,join(optionalDependencyPatterns," "));
  }
}
