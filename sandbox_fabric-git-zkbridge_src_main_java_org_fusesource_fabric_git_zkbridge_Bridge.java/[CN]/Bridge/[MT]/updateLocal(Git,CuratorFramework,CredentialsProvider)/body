{
  String remoteName="origin";
  try {
    git.fetch().setCredentialsProvider(credentialsProvider).setRemote(remoteName).call();
  }
 catch (  Exception e) {
    return;
  }
  Map<String,Ref> localBranches=new HashMap<String,Ref>();
  Map<String,Ref> remoteBranches=new HashMap<String,Ref>();
  Set<String> gitVersions=new HashSet<String>();
  for (  Ref ref : git.branchList().setListMode(ListBranchCommand.ListMode.ALL).call()) {
    if (ref.getName().startsWith("refs/remotes/" + remoteName + "/")) {
      String name=ref.getName().substring(("refs/remotes/" + remoteName + "/").length());
      if (!"master".equals(name) && !name.endsWith("-tmp")) {
        remoteBranches.put(name,ref);
        gitVersions.add(name);
      }
    }
 else     if (ref.getName().startsWith("refs/heads/")) {
      String name=ref.getName().substring(("refs/heads/").length());
      if (!name.equals("master") && !name.endsWith("-tmp")) {
        localBranches.put(name,ref);
        gitVersions.add(name);
      }
    }
  }
  for (  String version : gitVersions) {
    if (!remoteBranches.containsKey(version)) {
      git.branchDelete().setBranchNames(localBranches.get(version).getName()).setForce(true).call();
    }
 else     if (!localBranches.containsKey(version)) {
      git.branchCreate().setName(version).call();
      git.reset().setMode(ResetCommand.ResetType.HARD).setRef(remoteBranches.get(version).getName()).call();
    }
 else {
      String localCommit=localBranches.get(version).getObjectId().getName();
      String remoteCommit=remoteBranches.get(version).getObjectId().getName();
      if (!localCommit.equals(remoteCommit)) {
        git.clean().setCleanDirectories(true).call();
        git.checkout().setName("HEAD").setForce(true).call();
        git.checkout().setName(version).setForce(true).call();
        MergeResult result=git.merge().setStrategy(MergeStrategy.THEIRS).include(remoteBranches.get(version).getObjectId()).call();
      }
    }
  }
}
