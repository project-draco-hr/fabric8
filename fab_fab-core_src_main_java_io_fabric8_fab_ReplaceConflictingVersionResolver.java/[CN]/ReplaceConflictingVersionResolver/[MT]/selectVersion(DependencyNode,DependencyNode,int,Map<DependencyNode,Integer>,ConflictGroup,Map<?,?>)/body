{
  Integer smallestDepth=depths.get(node);
  if (smallestDepth == null || smallestDepth.intValue() > depth) {
    depths.put(node,Integer.valueOf(depth));
  }
 else {
    return;
  }
  Object key=conflictIds.get(node);
  if (group.key.equals(key)) {
    Position pos=new Position(parent,depth);
    if (parent != null) {
      group.positions.add(pos);
    }
    if (!group.isAcceptable(node.getVersion())) {
      return;
    }
    group.candidates.put(node,pos);
    VersionConstraint versionConstraint=node.getVersionConstraint();
    if (versionConstraint != null && versionConstraint.getRange() != null) {
      group.constraints.add(versionConstraint);
    }
    if (group.version == null || isNearer(pos,node.getVersion(),group.position,group.version)) {
      group.version=node.getVersion();
      group.versionDependency=node;
      group.position=pos;
    }
    if (!group.isAcceptable(group.version)) {
      group.version=null;
      group.versionDependency=null;
      for (Iterator<Map.Entry<DependencyNode,Position>> it=group.candidates.entrySet().iterator(); it.hasNext(); ) {
        Map.Entry<DependencyNode,Position> entry=it.next();
        Version version=entry.getKey().getVersion();
        pos=entry.getValue();
        if (!group.isAcceptable(version)) {
          it.remove();
        }
 else         if (group.version == null || isNearer(pos,version,group.position,group.version)) {
          group.version=version;
          group.versionDependency=entry.getKey();
          group.position=pos;
        }
      }
      if (group.version == null) {
        Collection<String> versions=new LinkedHashSet<String>();
        for (        VersionConstraint constraint : group.constraints) {
          versions.add(constraint.toString());
        }
        throw new UnsolvableVersionConflictException(Collections.<List<DependencyNode>>emptyList());
      }
    }
  }
  depth++;
  for (  DependencyNode child : node.getChildren()) {
    selectVersion(child,node,depth,depths,group,conflictIds);
  }
}
