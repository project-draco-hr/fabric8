{
  String namespace=event.getNamespace();
  String buildName=event.getConfigName();
  String buildUuid=event.getUid();
  String buildLink=event.getBuildLink();
  System.out.println("Build: " + buildUuid + " for config: "+ buildName+ " finished. Status: "+ event.getStatus()+ " link: "+ buildLink);
  BuildCorrelationKey key=BuildCorrelationKey.create(event);
  Map<String,String> signalObject=new HashMap<>();
  signalObject.put("buildUuid",buildUuid);
  signalObject.put("buildLink",buildLink);
  BuildFinishedDTO buildFinishedDTO=new BuildFinishedDTO(event);
  Long workItemId=buildProcessCorrelator.findWorkItemIdForBuild(key);
  if (workItemId == null) {
    String startNodeName=getStartSignalName(namespace,buildName);
    LOG.info("No existing processes associated with build " + key + " so lets signal a new process to start");
    Map<String,Object> inputParameters=new HashMap<>();
    inputParameters.put("startSignalName",startNodeName);
    LOG.info("Starting process: " + startBuildProcessId + " with inputParameters: "+ inputParameters);
    ProcessInstance processInstance=ksession.startProcess(startBuildProcessId,inputParameters);
  }
 else {
    Map<String,Object> results=new HashMap<>();
    populateParameters(results,buildFinishedDTO);
    LOG.info("Completing work item id: " + workItemId + " for "+ key+ " with data: "+ results);
    try {
      ksession.getWorkItemManager().completeWorkItem(workItemId,results);
    }
 catch (    Exception e) {
      LOG.error("Could not complete work item " + workItemId + " for "+ key+ " with data: "+ results+ ". Reason: "+ e,e);
    }
  }
}
