{
  if (location.startsWith(FAB_PROTOCOL)) {
    String url=location.substring(FAB_PROTOCOL.length());
    downloader.download(url,new AgentUtils.DownloadCallback(){
      @Override public void downloaded(      File file,      int pendings) throws Exception {
        if (listener != null) {
          listener.onDownload(file,pendings);
        }
        FabResolver resolver=fabResolverFactory.getResolver(file.toURI().toURL());
        FabBundleInfo fabInfo=resolver.getInfo();
        ResourceImpl resource=(ResourceImpl)manageResource(location,fabInfo.getManifest(),new StreamProvider.Fab(fabInfo));
        for (        String name : fabInfo.getFeatures()) {
          registerMatchingFeatures(name);
          requireFeature(name,resource);
        }
        for (        DependencyTree dep : fabInfo.getBundles()) {
          File depFile=dep.getJarFile();
          Attributes attrs=getAttributes(dep.getJarURL().toString(),depFile);
          if (attrs.getValue(Constants.BUNDLE_SYMBOLICNAME) != null) {
            manageResource(getMvnUrl(dep),attrs,new StreamProvider.File(depFile));
          }
        }
      }
    }
);
  }
 else   if (location.startsWith(REQ_PROTOCOL)) {
    try {
      ResourceImpl resource=new ResourceImpl(location,"dummy",Version.emptyVersion);
      for (      Requirement req : ResourceBuilder.parseRequirement(resource,location.substring(REQ_PROTOCOL.length()))) {
        resource.addRequirement(req);
      }
      resources.put(location,resource);
    }
 catch (    BundleException e) {
      throw new IOException("Error parsing requirement",e);
    }
  }
 else {
    if (urlHandlersTimeout >= 0) {
      try {
        List<String> filters=new ArrayList<String>();
        int oldSize=-1;
        String tmpUrl=location;
        while (filters.size() > oldSize) {
          oldSize=filters.size();
          for (          String protocol : PROTOCOLS) {
            if (tmpUrl.startsWith(protocol + ":")) {
              tmpUrl=tmpUrl.substring(protocol.length() + 1);
              String filter="(&(objectClass=org.osgi.service.url.URLStreamHandlerService)(url.handler.protocol=" + protocol + "))";
              filters.add(filter);
              break;
            }
          }
        }
        if (!filters.isEmpty()) {
          BundleContext context=FrameworkUtil.getBundle(getClass()).getBundleContext();
          List<ServiceTracker> trackers=new ArrayList<ServiceTracker>();
          for (          String filter : filters) {
            Filter flt=FrameworkUtil.createFilter(filter);
            ServiceTracker tracker=new ServiceTracker(context,flt,null);
            tracker.open();
            trackers.add(tracker);
          }
          long t0=System.currentTimeMillis();
          boolean hasAll=false;
          while (!hasAll && (System.currentTimeMillis() - t0) < urlHandlersTimeout) {
            hasAll=true;
            for (            ServiceTracker tracker : trackers) {
              hasAll&=tracker.waitForService(100) != null;
            }
          }
          for (          ServiceTracker tracker : trackers) {
            tracker.close();
          }
          if (!hasAll) {
            throw new TimeoutException("Timed out waiting for URL handlers: ");
          }
        }
      }
 catch (      Exception e) {
        throw new IOException("Unable to download " + location,e);
      }
    }
    downloader.download(location,new AgentUtils.DownloadCallback(){
      @Override public void downloaded(      File file,      int pendings) throws Exception {
        if (listener != null) {
          listener.onDownload(file,pendings);
        }
        manageResource(location,file);
      }
    }
);
  }
}
