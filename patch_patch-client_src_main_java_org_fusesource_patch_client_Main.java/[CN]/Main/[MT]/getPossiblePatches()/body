{
  final List<Patch> patches=new ArrayList<Patch>();
  final DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();
  final CountDownLatch latch=new CountDownLatch(repos.size() * artifacts.size());
  for (  final String repo : repos) {
    for (    final String artifact : artifacts) {
      executor.submit(new Runnable(){
        @Override public void run(){
          try {
            String[] mvn=artifact.split(":");
            URL base=new URL(repo + mvn[0].replace('.','/') + "/"+ mvn[1]+ "/");
            URL metadata=new URL(base,"maven-metadata.xml");
            URLConnection con=metadata.openConnection();
            if (metadata.getUserInfo() != null) {
              con.setRequestProperty("Authorization","Basic " + new sun.misc.BASE64Encoder().encode(metadata.getUserInfo().getBytes()));
            }
            InputStream is=con.getInputStream();
            try {
              Document doc=dbf.newDocumentBuilder().parse(is);
              NodeList versions=doc.getDocumentElement().getElementsByTagName("version");
              for (int i=0; i < versions.getLength(); i++) {
                Node version=versions.item(i);
                String v=version.getTextContent();
                URL p=new URL(base,v + "/" + mvn[1]+ "-"+ v+ "-patch.patch");
synchronized (patches) {
                  Patch patch=new Patch();
                  patch.artifact=artifact;
                  patch.repo=repo;
                  patch.version=v;
                  patch.location=p;
                  patches.add(patch);
                }
              }
            }
  finally {
              is.close();
            }
          }
 catch (          FileNotFoundException e) {
          }
catch (          Exception e) {
            System.err.println("Error in " + repo + artifact+ ": "+ e.getMessage());
          }
 finally {
            latch.countDown();
          }
        }
      }
);
    }
  }
  latch.await();
  return patches;
}
