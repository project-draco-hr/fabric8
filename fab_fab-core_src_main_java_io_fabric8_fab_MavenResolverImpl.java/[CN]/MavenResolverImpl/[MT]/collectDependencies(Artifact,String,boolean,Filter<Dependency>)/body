{
  RepositorySystem repositorySystem=getRepositorySystem();
  final MavenRepositorySystemSession session=createRepositorSystemSession(offline,repositorySystem);
  List<RemoteRepository> repos=getRemoteRepositories();
  ArtifactDescriptorResult artifactDescriptorResult=repositorySystem.readArtifactDescriptor(session,new ArtifactDescriptorRequest(root,repos,null));
  repos.addAll(artifactDescriptorResult.getRepositories());
  Dependency rootDependency=new Dependency(root,null);
  List<Dependency> dependencies=artifactDescriptorResult.getDependencies();
  final DefaultDependencyNode rootNode=new DefaultDependencyNode(rootDependency);
  GenericVersionScheme versionScheme=new GenericVersionScheme();
  rootNode.setVersion(versionScheme.parseVersion(pomVersion));
  rootNode.setVersionConstraint(versionScheme.parseVersionConstraint(pomVersion));
  DependencyNode pomNode=rootNode;
  final Filter<Dependency> shouldExclude=Filters.or(DependencyFilters.testScopeFilter,excludeDependencyFilter);
  DependencySelector dependencySelector=new AndDependencySelector(new ScopeDependencySelector("test"),new ExclusionDependencySelector(),new DependencySelector(){
    @Override public DependencySelector deriveChildSelector(    DependencyCollectionContext context){
      return this;
    }
    @Override public boolean selectDependency(    Dependency dependency){
      try {
        return !DependencyFilters.matches(dependency,shouldExclude);
      }
 catch (      Exception e) {
        failedToMakeDependencyTree(dependency,e);
        return false;
      }
    }
  }
);
  session.setDependencySelector(dependencySelector);
  if (true) {
    for (    Dependency dependency : dependencies) {
      DependencyNode node=resolveDepedencies(repositorySystem,session,repos,pomNode,dependency,shouldExclude);
      if (node != null) {
        pomNode.getChildren().add(node);
      }
    }
  }
 else {
    DependencyNode node=resolveDepedencies(repositorySystem,session,repos,pomNode,rootDependency,shouldExclude);
    if (node != null) {
      pomNode=node;
    }
  }
  DependencyGraphTransformationContext tranformContext=new DependencyGraphTransformationContext(){
    Map map=new HashMap();
    public RepositorySystemSession getSession(){
      return session;
    }
    public Object get(    Object key){
      return map.get(key);
    }
    public Object put(    Object key,    Object value){
      return map.put(key,value);
    }
  }
;
  DependencyGraphTransformer transformer=new ReplaceConflictingVersionResolver();
  pomNode=transformer.transformGraph(pomNode,tranformContext);
  DependencyTreeResult result=new DependencyTreeResult(pomNode,this,excludeDependencyFilter);
  List<DependencyTree.DuplicateDependency> duplicates=result.getTree().checkForDuplicateDependencies();
  for (  DependencyTree.DuplicateDependency duplicate : duplicates) {
    LOGGER.warn("Duplicate dependency: " + duplicate);
  }
  return result;
}
