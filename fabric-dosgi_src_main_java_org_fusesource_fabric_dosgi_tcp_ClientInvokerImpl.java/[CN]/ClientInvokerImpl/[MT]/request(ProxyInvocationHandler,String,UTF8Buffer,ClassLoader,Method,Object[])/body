{
  final long correlation=correlationGenerator.incrementAndGet();
  DataByteArrayOutputStream baos=new DataByteArrayOutputStream((int)(handler.lastRequestSize * 1.10));
  baos.writeInt(0);
  baos.writeVarLong(correlation);
  writeBuffer(baos,service);
  writeBuffer(baos,encodeMethod(method));
  SerializationStrategy serializationStrategy=new ObjectSerializationStrategy();
  final InvocationStrategy strategy;
  if (AsyncInvocationStrategy.isAsyncMethod(method)) {
    strategy=new AsyncInvocationStrategy(serializationStrategy);
  }
 else {
    strategy=new BlockingInvocationStrategy(serializationStrategy);
  }
  final ResponseFuture future=strategy.request(classLoader,method,args,baos);
  final Buffer command=baos.toBuffer();
  BufferEditor editor=command.buffer().bigEndianEditor();
  editor.writeInt(command.length);
  handler.lastRequestSize=command.length;
  queue.execute(new Runnable(){
    public void run(){
      try {
        TransportPool pool=transports.get(address);
        if (pool == null) {
          pool=new InvokerTransportPool(address,queue);
          transports.put(address,pool);
          pool.start();
        }
        requests.put(correlation,future);
        pool.offer(command);
      }
 catch (      Exception e) {
        LOGGER.info("Error while sending request",e);
      }
    }
  }
);
  return future.get(timeout,TimeUnit.MILLISECONDS);
}
