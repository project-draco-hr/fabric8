{
  assertValid();
  try {
    Repository repository=git.getRepository();
    StoredConfig config=repository.getConfig();
    String url=config.getString("remote",remote,"url");
    if (Strings.isNullOrBlank(url)) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("No remote repository defined for the git repository at " + GitHelpers.getRootGitDirectory(git) + " so not doing a pull");
      }
      return;
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("Performing a fetch in git repository " + GitHelpers.getRootGitDirectory(git) + " on remote URL: "+ url);
    }
    boolean hasChanged=false;
    try {
      git.fetch().setTimeout(10).setCredentialsProvider(credentialsProvider).setRemote(remote).call();
    }
 catch (    Exception e) {
      LOG.debug("Fetch failed. Ignoring");
      return;
    }
    Map<String,Ref> localBranches=new HashMap<String,Ref>();
    Map<String,Ref> remoteBranches=new HashMap<String,Ref>();
    Set<String> gitVersions=new HashSet<String>();
    for (    Ref ref : git.branchList().setListMode(ListBranchCommand.ListMode.ALL).call()) {
      if (ref.getName().startsWith("refs/remotes/" + remote + "/")) {
        String name=ref.getName().substring(("refs/remotes/" + remote + "/").length());
        remoteBranches.put(name,ref);
        gitVersions.add(name);
      }
 else       if (ref.getName().startsWith("refs/heads/")) {
        String name=ref.getName().substring(("refs/heads/").length());
        localBranches.put(name,ref);
        gitVersions.add(name);
      }
    }
    for (    String version : gitVersions) {
      if (remoteBranches.isEmpty()) {
      }
 else       if (!remoteBranches.containsKey(version)) {
        if (doDeleteBranches && !version.equals(MASTER_BRANCH)) {
          try {
            git.branchDelete().setBranchNames(localBranches.get(version).getName()).setForce(true).call();
          }
 catch (          CannotDeleteCurrentBranchException ex) {
            git.checkout().setName(MASTER_BRANCH).setForce(true).call();
            git.branchDelete().setBranchNames(localBranches.get(version).getName()).setForce(true).call();
          }
          removeVersion(version);
          hasChanged=true;
        }
      }
 else       if (!localBranches.containsKey(version)) {
        addVersion(version);
        git.checkout().setCreateBranch(true).setName(version).setStartPoint(remote + "/" + version).setUpstreamMode(CreateBranchCommand.SetupUpstreamMode.TRACK).setForce(true).call();
        hasChanged=true;
      }
 else {
        String localCommit=localBranches.get(version).getObjectId().getName();
        String remoteCommit=remoteBranches.get(version).getObjectId().getName();
        if (!localCommit.equals(remoteCommit)) {
          git.clean().setCleanDirectories(true).call();
          git.checkout().setName("HEAD").setForce(true).call();
          git.checkout().setName(version).setForce(true).call();
          MergeResult result=git.merge().setStrategy(MergeStrategy.THEIRS).include(remoteBranches.get(version).getObjectId()).call();
          if (result.getMergeStatus() != MergeResult.MergeStatus.ALREADY_UP_TO_DATE && hasChanged(git,localCommit,remoteCommit)) {
            hasChanged=true;
          }
        }
      }
    }
    if (hasChanged) {
      LOG.debug("Changed after pull!");
      if (credentialsProvider != null) {
        File profilesDirectory=getProfilesDirectory(git);
      }
      fireChangeNotifications();
    }
  }
 catch (  Throwable e) {
    LOG.error("Failed to pull from the remote git repo " + GitHelpers.getRootGitDirectory(git) + ". Reason: "+ e,e);
  }
}
