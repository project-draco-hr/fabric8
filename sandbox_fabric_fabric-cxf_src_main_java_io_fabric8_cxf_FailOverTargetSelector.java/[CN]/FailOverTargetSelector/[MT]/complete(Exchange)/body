{
  InvocationKey key=new InvocationKey(exchange);
  InvocationContext invocation=null;
  invocation=inProgress.get(key);
  boolean failOver=false;
  if (requiresFailOver(exchange)) {
    Endpoint failOverTarget=getFailOverTarget(exchange,invocation);
    if (failOverTarget != null) {
      setEndpoint(failOverTarget);
      selectedConduit.close();
      selectedConduit=null;
      Exception prevExchangeFault=(Exception)exchange.remove(Exception.class.getName());
      Message outMessage=exchange.getOutMessage();
      Exception prevMessageFault=outMessage.getContent(Exception.class);
      outMessage.setContent(Exception.class,null);
      overrideAddressProperty(invocation.getContext());
      Retryable retry=exchange.get(Retryable.class);
      exchange.clear();
      if (retry != null) {
        try {
          failOver=true;
          retry.invoke(invocation.getBindingOperationInfo(),invocation.getParams(),invocation.getContext(),exchange);
        }
 catch (        Exception e) {
          if (exchange.get(Exception.class) != null) {
            exchange.put(Exception.class,prevExchangeFault);
          }
          if (outMessage.getContent(Exception.class) != null) {
            outMessage.setContent(Exception.class,prevMessageFault);
          }
        }
      }
    }
 else {
      setEndpoint(invocation.retrieveOriginalEndpoint(endpoint));
    }
  }
  if (!failOver) {
    getLogger().info("FailOver is not required.");
    inProgress.remove(key);
    super.complete(exchange);
  }
}
