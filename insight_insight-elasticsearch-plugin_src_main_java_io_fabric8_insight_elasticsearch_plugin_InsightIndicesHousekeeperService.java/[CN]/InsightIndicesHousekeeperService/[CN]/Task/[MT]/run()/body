{
  boolean reschedule=true;
  try {
    ClusterAdminClient clusterAdminClient=adminClient.cluster();
    ClusterStateResponse state=clusterAdminClient.state(clusterAdminClient.prepareState().request()).actionGet();
    if (!state.getState().nodes().getLocalNode().isMasterNode()) {
      return;
    }
    Set<String> toClose=new HashSet<>();
    Set<String> toDelete=new HashSet<>();
    LocalDate now=new LocalDate();
    for (    ObjectObjectCursor<String,IndexMetaData> it : state.getState().metaData().indices()) {
      String index=it.value.getIndex();
      Matcher matcher=pattern.matcher(index);
      if (matcher.find()) {
        LocalDate date=new LocalDate(Integer.parseInt(matcher.group(1)),Integer.parseInt(matcher.group(2)),Integer.parseInt(matcher.group(3)));
        int daysOld=Days.daysBetween(date,now).getDays();
        if (daysOld > 0 && daysOpened > 0 && daysOld > daysOpened) {
          if (daysOld > daysOpened && daysOld <= daysClosed) {
            logger.debug("Adding index to close: Index {} is {} day(s) old",index,daysOld);
            toClose.add(index);
          }
 else           if (daysClosed >= 0 && daysOld > daysClosed && daysOld > daysStored) {
            logger.debug("Adding index to delete: Index {} is {} day(s) old",index,daysOld);
            toDelete.add(index);
          }
        }
 else {
          logger.debug("Ignoring index: Index {} is only {} day(s) old",index,daysOld);
        }
      }
 else {
        logger.debug("Ignoring index: Name {} does not match the supported pattern ({})",index,pattern.pattern());
      }
      IndicesAdminClient indicesAdminClient=adminClient.indices();
      if (!toClose.isEmpty()) {
        logger.info("Closing indices: {}",toClose);
        String[] indices=toClose.toArray(new String[toClose.size()]);
        CloseIndexRequest req=indicesAdminClient.prepareClose(indices).request();
        indicesAdminClient.close(req).actionGet();
      }
      if (!toDelete.isEmpty()) {
        logger.info("Deleting indices: {}",toDelete);
        String[] indices=toDelete.toArray(new String[toDelete.size()]);
        DeleteIndexRequest req=indicesAdminClient.prepareDelete(indices).request();
        indicesAdminClient.delete(req).actionGet();
      }
    }
  }
 catch (  ElasticsearchException e) {
    if (e.getCause() instanceof InterruptedException) {
      reschedule=true;
    }
 else {
      logger.error("Error performing indices management",e);
    }
  }
 finally {
    if (reschedule) {
      future=threadPool.schedule(interval,ThreadPool.Names.GENERIC,this);
    }
  }
}
