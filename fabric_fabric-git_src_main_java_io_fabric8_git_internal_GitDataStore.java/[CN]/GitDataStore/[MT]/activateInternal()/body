{
  try {
    super.activateInternal();
    defaultProxySelector=ProxySelector.getDefault();
    ProxySelector fabricProxySelector=new FabricGitLocalHostProxySelector(defaultProxySelector,gitProxyService.getOptional());
    ProxySelector.setDefault(fabricProxySelector);
    LOG.info("Setting up FabricProxySelector: {}",fabricProxySelector);
    GitService optionalService=gitService.getOptional();
    if (configuredUrl != null) {
      gitListener.onRemoteUrlChanged(configuredUrl);
      remoteUrl=configuredUrl;
    }
 else     if (optionalService != null) {
      optionalService.addGitListener(gitListener);
      remoteUrl=optionalService.getRemoteUrl();
      gitListener.onRemoteUrlChanged(remoteUrl);
    }
    forceGetVersions();
    LOG.info("starting to pull from remote repository every {} millis",gitPullPeriod);
    threadPool.scheduleWithFixedDelay(new Runnable(){
      @Override public void run(){
        try {
          LOG.trace("Performing timed pull");
          pull();
          LOG.trace("Performing timed push");
          push();
          LOG.debug("Performed timed pull and push done");
        }
 catch (        Throwable e) {
          LOG.debug("Error during performed timed pull/push due " + e.getMessage(),e);
          LOG.warn("Error during performed timed pull/push due " + e.getMessage() + ". This exception is ignored.");
        }
      }
      @Override public String toString(){
        return "TimedPullTask";
      }
    }
,gitPullPeriod,gitPullPeriod,TimeUnit.MILLISECONDS);
  }
 catch (  Exception ex) {
    throw new FabricException("Failed to start GitDataStore:",ex);
  }
}
