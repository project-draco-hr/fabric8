{
  initialPull=false;
  try {
    super.activateInternal();
    if (gitProxyService.getOptional() != null) {
      defaultProxySelector=ProxySelector.getDefault();
      ProxySelector fabricProxySelector=new FabricGitLocalHostProxySelector(defaultProxySelector,gitProxyService.getOptional());
      ProxySelector.setDefault(fabricProxySelector);
      LOG.info("Setting up FabricProxySelector: {}",fabricProxySelector);
    }
    GitService optionalService=gitService.getOptional();
    if (configuredUrl != null) {
      gitListener.onRemoteUrlChanged(configuredUrl);
      remoteUrl=configuredUrl;
    }
 else     if (optionalService != null) {
      optionalService.addGitListener(gitListener);
      remoteUrl=optionalService.getRemoteUrl();
      gitListener.onRemoteUrlChanged(remoteUrl);
    }
    forceGetVersions();
    LOG.info("Starting to push to remote git repository every {} millis",gitPushInterval);
    threadPool.scheduleWithFixedDelay(new Runnable(){
      @Override public void run(){
        try {
          if (!initialPull) {
            LOG.trace("Performing initial pull");
            pull();
            initialPull=true;
            LOG.debug("Performing initial pull done");
          }
          LOG.trace("Performing timed push");
          push();
          LOG.debug("Performed timed pull and push done");
        }
 catch (        Throwable e) {
          LOG.debug("Error during performed timed pull/push due " + e.getMessage(),e);
          LOG.warn("Error during performed timed pull/push due " + e.getMessage() + ". This exception is ignored.");
        }
      }
      @Override public String toString(){
        return "TimedPushTask";
      }
    }
,1000,gitPushInterval,TimeUnit.MILLISECONDS);
    counter=new SharedCount(getCurator(),ZkPath.GIT_TRIGGER.getPath(),0);
    counter.addListener(new SharedCountListener(){
      @Override public void countHasChanged(      SharedCountReader sharedCountReader,      int value) throws Exception {
        LOG.debug("Watch counter updated to " + value + ", doing a pull");
        try {
          Thread.sleep(1000);
          pull();
        }
 catch (        Throwable e) {
          LOG.debug("Error during pull due " + e.getMessage(),e);
          LOG.warn("Error during pull due " + e.getMessage() + ". This exception is ignored.");
        }
      }
      @Override public void stateChanged(      CuratorFramework curatorFramework,      ConnectionState connectionState){
      }
    }
);
    counter.start();
  }
 catch (  Exception ex) {
    throw new FabricException("Failed to start GitDataStore:",ex);
  }
}
