{
  expression=expression.trim();
  if (!checkParenthesis(expression)) {
    throw new IllegalArgumentException("Not a matching number of '(' and ')' parenthesis: " + expression);
  }
  int index=0, start=-1, end;
  int[] tokens=new int[32];
  int token=0;
  for (; ; ) {
    if (index >= expression.length()) {
      if (start >= 0) {
        end=index;
        tokens[token++]=start;
        tokens[token++]=end;
      }
      break;
    }
    char c=expression.charAt(index);
    if (Character.isWhitespace(c)) {
      if (start >= 0) {
        end=index;
        tokens[token++]=start;
        tokens[token++]=end;
        start=-1;
      }
      index++;
    }
 else     if (c == '(') {
      if (start >= 0) {
        end=index;
        tokens[token++]=start;
        tokens[token++]=end;
        start=-1;
      }
 else {
        start=index;
        end=indexOfParenthesisMatch(expression,start);
        tokens[token++]=start + 1;
        tokens[token++]=end;
        start=-1;
        index=end + 1;
      }
    }
 else {
      if (start < 0) {
        start=index;
      }
      index++;
    }
  }
  for (int i=0; i < token; i+=2) {
    if (expression.regionMatches(tokens[i],"or",0,tokens[i + 1] - tokens[i])) {
      if (i == 0 || i > token - 2) {
        throw new IllegalArgumentException("Bad syntax: " + expression);
      }
      PathMatcher left=doParse(expression.substring(tokens[0],tokens[i - 1]));
      PathMatcher right=doParse(expression.substring(tokens[i + 2],tokens[token - 1]));
      return new OrMatcher(left,right);
    }
  }
  for (int i=0; i < token; i+=2) {
    if (expression.regionMatches(tokens[i],"and",0,tokens[i + 1] - tokens[i])) {
      if (i == 0 || i > token - 2) {
        throw new IllegalArgumentException("Bad syntax: " + expression);
      }
      PathMatcher left=doParse(expression.substring(tokens[0],tokens[i - 1]));
      PathMatcher right=doParse(expression.substring(tokens[i + 2],tokens[token - 1]));
      return new AndMatcher(left,right);
    }
  }
  if (token > 2 && expression.regionMatches(tokens[0],"not",0,tokens[1] - tokens[0])) {
    PathMatcher right=doParse(expression.substring(tokens[2],tokens[token - 1]));
    return new NotMatcher(right);
  }
  if (!expression.matches("[a-z]+:.*")) {
    expression="glob:" + expression;
  }
  return Matchers.parse(expression);
}
