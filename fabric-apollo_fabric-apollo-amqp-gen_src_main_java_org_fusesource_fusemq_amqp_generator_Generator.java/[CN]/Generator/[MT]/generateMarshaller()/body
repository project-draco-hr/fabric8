{
  File out=new File(outputDirectory,getMarshallerPackage().replace(".",SLASH) + SLASH + "AmqpMarshaller.java");
  BufferedWriter writer=new BufferedWriter(new FileWriter(out));
  Utils.writeJavaCopyWrite(writer);
  writer.write("package " + getMarshallerPackage() + ";");
  writer.newLine();
  writer.newLine();
  TreeSet<String> imports=new TreeSet<String>();
  imports.add("java.util.HashMap");
  imports.add(getMarshallerPackage() + ".Encoder.*");
  imports.add(getPackagePrefix() + ".marshaller.AmqpVersion");
  imports.add(getPackagePrefix() + ".marshaller.Encoded");
  writeMarshallerImports(writer,false,imports,getMarshallerPackage());
  writer.newLine();
  Utils.writeAutoGeneratedWarning(writer,0);
  writer.write("public class AmqpMarshaller implements " + getPackagePrefix() + ".marshaller.AmqpMarshaller {");
  writer.newLine();
  writer.newLine();
  writer.write(Utils.tab(1) + "static AmqpMarshaller SINGLETON = new AmqpMarshaller();");
  writer.newLine();
  writer.newLine();
  writer.write(Utils.tab(1) + "public static AmqpVersion VERSION = new AmqpVersion((short)" + DEFINITIONS.get("MAJOR").getValue()+ ", (short)"+ DEFINITIONS.get("MINOR").getValue()+ ", (short)"+ DEFINITIONS.get("REVISION").getValue()+ ");");
  writer.newLine();
  writer.newLine();
  writer.write(Utils.tab(1) + "public static AmqpMarshaller getMarshaller() {");
  writer.newLine();
  writer.write(Utils.tab(2) + "return SINGLETON;");
  writer.newLine();
  writer.write(Utils.tab(1) + "}");
  writer.newLine();
  writer.newLine();
  writer.write(Utils.tab(1) + "private static HashMap<Long, DescribedTypeMarshaller<?>> DESCRIBED_NUMERIC_TYPES = new HashMap<Long, DescribedTypeMarshaller<?>>();");
  writer.newLine();
  writer.write(Utils.tab(1) + "private static HashMap<String, DescribedTypeMarshaller<?>> DESCRIBED_SYMBOLIC_TYPES = new HashMap<String, DescribedTypeMarshaller<?>>();");
  writer.newLine();
  writer.write(Utils.tab(1) + "static {");
  writer.newLine();
  for (  AmqpClass amqpClass : TypeRegistry.getGeneratedTypes()) {
    if (amqpClass.isDescribed()) {
      writer.write(Utils.tab(2) + "DESCRIBED_NUMERIC_TYPES.put(" + amqpClass.getTypeMapping()+ "Marshaller.NUMERIC_ID, "+ amqpClass.getTypeMapping()+ "Marshaller.SINGLETON);");
      writer.newLine();
      writer.write(Utils.tab(2) + "DESCRIBED_SYMBOLIC_TYPES.put(" + amqpClass.getTypeMapping()+ "Marshaller.SYMBOLIC_ID, "+ amqpClass.getTypeMapping()+ "Marshaller.SINGLETON);");
      writer.newLine();
    }
  }
  writer.write(Utils.tab(1) + "}");
  writer.newLine();
  writer.newLine();
  Utils.writeJavaComment(writer,1,"@return the protocol version of the marshaller");
  writer.write(Utils.tab(1) + "public final AmqpVersion getVersion() {");
  writer.newLine();
  writer.write(Utils.tab(2) + "return VERSION;");
  writer.newLine();
  writer.write(Utils.tab(1) + "}");
  writer.newLine();
  writer.newLine();
  writer.write(Utils.tab(1) + "public final " + TypeRegistry.any().typeMapping+ " unmarshalType(DataInput in) throws IOException, AmqpEncodingError {");
  writer.newLine();
  writer.write(Utils.tab(2) + "return Encoder.unmarshalType(in);");
  writer.newLine();
  writer.write(Utils.tab(1) + "}");
  writer.newLine();
  writer.newLine();
  writer.write(Utils.tab(1) + "public final " + TypeRegistry.any().typeMapping+ " decodeType(Buffer source) throws AmqpEncodingError {");
  writer.newLine();
  writer.write(Utils.tab(2) + "return Encoder.decode(source);");
  writer.newLine();
  writer.write(Utils.tab(1) + "}");
  writer.newLine();
  writer.newLine();
  writer.write(Utils.tab(1) + "final " + TypeRegistry.any().typeMapping+ " decodeType(EncodedBuffer encoded) throws AmqpEncodingError {");
  writer.newLine();
  writer.write(Utils.tab(2) + "if(encoded.isDescribed()) {");
  writer.newLine();
  writer.write(Utils.tab(2) + "return decodeType(encoded.asDescribed());");
  writer.newLine();
  writer.write(Utils.tab(2) + "}");
  writer.newLine();
  writer.newLine();
  writer.write(Utils.tab(2) + "switch(encoded.getEncodingFormatCode()) {");
  writer.newLine();
  for (  AmqpClass amqpClass : TypeRegistry.getGeneratedTypes()) {
    if (amqpClass.isPrimitive() && !amqpClass.getName().equals("*")) {
      writer.write(Utils.tab(2) + "//" + amqpClass.getTypeMapping()+ " Encoded: ");
      writer.newLine();
      if (!amqpClass.hasMultipleEncodings() && !amqpClass.hasNonFixedEncoding()) {
        writer.write(Utils.tab(2) + "case " + amqpClass.getTypeMapping()+ "Marshaller.FORMAT_CODE: ");
        writer.newLine();
      }
 else {
        for (        AmqpEncoding encoding : amqpClass.encodings) {
          writer.write(Utils.tab(2) + "case (byte) " + encoding.getCode()+ ":");
          writer.newLine();
        }
      }
      writer.write(Utils.tab(2) + "{");
      writer.newLine();
      writer.write(Utils.tab(3) + "return " + amqpClass.bufferMapping+ ".create("+ amqpClass.getMarshaller()+ ".createEncoded(encoded));");
      writer.newLine();
      writer.write(Utils.tab(2) + "}");
      writer.newLine();
    }
  }
  writer.write(Utils.tab(2) + "default: {");
  writer.newLine();
  writer.write(Utils.tab(3) + "//TODO: Create an unknown or any type");
  writer.newLine();
  writer.write(Utils.tab(3) + "throw new AmqpEncodingError(\"Unrecognized format code:\" + encoded.getEncodingFormatCode());");
  writer.newLine();
  writer.write(Utils.tab(2) + "}");
  writer.newLine();
  writer.write(Utils.tab(2) + "}");
  writer.newLine();
  writer.write(Utils.tab(1) + "}");
  writer.newLine();
  writer.newLine();
  writer.write(Utils.tab(1) + "final " + TypeRegistry.any().typeMapping+ " decodeType(DescribedBuffer buffer) throws AmqpEncodingError {");
  writer.newLine();
  writer.write(Utils.tab(2) + TypeRegistry.any().typeMapping + " descriptor = decodeType(buffer.getDescriptorBuffer());");
  writer.newLine();
  writer.write(Utils.tab(2) + "//TODO might want to revisit whether or not the cast is needed here:");
  writer.newLine();
  writer.write(Utils.tab(2) + "DescribedTypeMarshaller<?> dtm = null;");
  writer.newLine();
  writer.write(Utils.tab(2) + "if ( descriptor instanceof AmqpUlong ) {");
  writer.newLine();
  writer.write(Utils.tab(3) + "dtm = DESCRIBED_NUMERIC_TYPES.get(((AmqpUlong)descriptor).getValue().longValue());");
  writer.newLine();
  writer.write(Utils.tab(2) + "} else if ( descriptor instanceof AmqpSymbol ) {");
  writer.newLine();
  writer.write(Utils.tab(3) + "dtm = DESCRIBED_SYMBOLIC_TYPES.get(((AmqpSymbol)descriptor).getValue());");
  writer.newLine();
  writer.write(Utils.tab(2) + "} else if ( descriptor instanceof AmqpBoolean ) {");
  writer.newLine();
  writer.write(Utils.tab(3) + "dtm = MultipleMarshaller.SINGLETON;;");
  writer.newLine();
  writer.write(Utils.tab(2) + "}");
  writer.newLine();
  writer.newLine();
  writer.write(Utils.tab(2) + "if(dtm != null) {");
  writer.newLine();
  writer.write(Utils.tab(3) + "return dtm.decodeDescribedType(descriptor, buffer);");
  writer.newLine();
  writer.write(Utils.tab(2) + "}");
  writer.newLine();
  writer.newLine();
  writer.write(Utils.tab(2) + "//TODO spec actually indicates that we should be able to pass along unknown types. so we should just create");
  writer.newLine();
  writer.write(Utils.tab(2) + "//a placeholder type");
  writer.newLine();
  writer.write(Utils.tab(2) + "throw new AmqpEncodingError(\"Unrecognized described type:\" + descriptor);");
  writer.newLine();
  writer.write(Utils.tab(1) + "}");
  for (  AmqpClass amqpClass : TypeRegistry.getGeneratedTypes()) {
    if (amqpClass.needsMarshaller()) {
      if (amqpClass.name.equals("*")) {
        continue;
      }
      writer.newLine();
      writer.write(Utils.tab(1) + "public final Encoded<" + amqpClass.getValueMapping()+ "> encode("+ amqpClass.getJavaType()+ " data) throws AmqpEncodingError {");
      writer.newLine();
      writer.write(Utils.tab(2) + "return " + amqpClass.getJavaType()+ "Marshaller.encode(data);");
      writer.newLine();
      writer.write(Utils.tab(1) + "}");
      writer.newLine();
      writer.newLine();
      writer.write(Utils.tab(1) + "public Encoded<" + amqpClass.getValueMapping()+ "> decode"+ amqpClass.getJavaType()+ "(Buffer source, int offset) throws AmqpEncodingError {");
      writer.newLine();
      writer.write(Utils.tab(2) + "return " + amqpClass.getMarshaller()+ ".createEncoded(source, offset);");
      writer.newLine();
      writer.write(Utils.tab(1) + "}");
      writer.newLine();
      writer.newLine();
      writer.write(Utils.tab(1) + "public Encoded<" + amqpClass.getValueMapping()+ "> unmarshal"+ amqpClass.getJavaType()+ "(DataInput in) throws IOException, AmqpEncodingError {");
      writer.newLine();
      writer.write(Utils.tab(2) + "return " + amqpClass.getMarshaller()+ ".createEncoded(in);");
      writer.newLine();
      writer.write(Utils.tab(1) + "}");
      writer.newLine();
    }
  }
  writer.write("}");
  writer.flush();
  writer.close();
}
