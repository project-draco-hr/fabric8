{
  MavenProject project=getProject();
  Properties properties=project.getProperties();
  Map<String,Object> variables=new HashMap<>();
  Set<Map.Entry<Object,Object>> entries=properties.entrySet();
  for (  Map.Entry<Object,Object> entry : entries) {
    Object key=entry.getKey();
    Object value=entry.getValue();
    if (key instanceof String) {
      String keyText=key.toString();
      keyText=keyText.replace('.','_');
      variables.put(keyText,value);
    }
  }
  Map<String,String> labelMap=getLabels();
  String name=getKubernetesName();
  if (labelMap.isEmpty() && Strings.isNotBlank(name)) {
    labelMap.put("component",name);
  }
  KubernetesListBuilder builder=new KubernetesListBuilder().addNewReplicationControllerItem().withNewMetadata().withName(KubernetesHelper.validateKubernetesId(replicationControllerName,"fabric8.replicationController.name")).withLabels(labels).endMetadata().withNewSpec().withReplicas(replicaCount).withSelector(labelMap).withNewTemplate().withNewMetadata().withLabels(labelMap).endMetadata().withNewSpec().addNewContainer().withName(getKubernetesContainerName()).withImage(getDockerImage()).withImagePullPolicy(getImagePullPolicy()).withEnv(getEnvironmentVariables()).withPrivileged(getContainerPrivileged()).withPorts(getContainerPorts()).withVolumeMounts(getVolumeMounts()).withLivenessProbe(getLivenessProbe()).endContainer().withVolumes(getVolumes()).endSpec().endTemplate().endSpec().endReplicationControllerItem();
  if (serviceName != null) {
    ServiceBuilder serviceBuilder=new ServiceBuilder().withNewMetadata().withName(serviceName).withLabels(labelMap).endMetadata();
    ServiceFluent<ServiceBuilder>.SpecNested<ServiceBuilder> serviceSpecBuilder=serviceBuilder.withNewSpec().withSelector(labelMap);
    List<ServicePort> servicePorts=getServicePorts();
    System.out.println("Generated ports: " + servicePorts);
    boolean hasPorts=servicePorts != null & !servicePorts.isEmpty();
    if (hasPorts) {
      serviceSpecBuilder.withPorts(servicePorts);
    }
 else {
      serviceSpecBuilder.withPortalIP("None");
    }
    serviceSpecBuilder.endSpec();
    if (headlessServices || hasPorts) {
      builder=builder.addToServiceItems(serviceBuilder.build());
    }
  }
  Template template=getTemplate();
  String iconUrl=getIconUrl();
  boolean hasUrl=Strings.isNotBlank(iconUrl);
  if (!template.getParameters().isEmpty() || hasUrl) {
    Map<String,String> annotations=KubernetesHelper.getOrCreateAnnotations(template);
    if (hasUrl) {
      annotations.put(AnnotationKeys.ICON_URL,iconUrl);
    }
    addDocumentationAnnotations(template,annotations);
    builder=builder.addToTemplateItems(template);
  }
  KubernetesList kubernetesList=builder.build();
  Object result=Templates.combineTemplates(kubernetesList);
  try {
    ObjectMapper mapper=new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
    String generated=mapper.writeValueAsString(result);
    Files.writeToFile(kubernetesJson,generated,Charset.defaultCharset());
  }
 catch (  IOException e) {
    throw new IllegalArgumentException("Failed to generate Kubernetes JSON.",e);
  }
}
