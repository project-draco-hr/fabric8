{
  primitiveEncoder=getPackagePrefix() + "." + getInterfaces()+ "."+ "PrimitiveEncoder";
  baseEncoder=getPackagePrefix() + "." + getInterfaces()+ "."+ "BaseEncoder";
  String typeRegistry=getPackagePrefix() + "." + getMarshaller()+ "."+ "TypeRegistry";
  xmlDefinitionParser.parseXML();
  buildRestrictedTypeMapping();
  generatePrimitiveEncoderDecoder();
  registry=new TypeRegistry(cm,typeRegistry);
  registry.cls().field(JMod.PROTECTED | JMod.FINAL | JMod.STATIC,cm._getClass(baseEncoder),"ENCODER",JExpr.direct("Encoder.instance()"));
  JMethod singletonAccessor=registry.cls().method(JMod.PUBLIC | JMod.STATIC,cm._getClass(baseEncoder),"encoder");
  singletonAccessor.body()._return(JExpr.ref("ENCODER"));
  Log.info("\n%s",this);
  outputDirectory.mkdirs();
  try {
    interfaceGenerator.generateAbstractBases();
    describedTypeGenerator.createDescribedClasses(this);
    describedTypeGenerator.generateDescribedTypes();
    JMethod formatCodeMap=registry.cls().getMethod("getFormatCodeMap",new JType[]{});
    JMethod symbolicCodeMap=registry.cls().getMethod("getSymbolicCodeMap",new JType[]{});
    for (    String key : describedJavaClass.keySet()) {
      String value=describedJavaClass.get(key);
      JDefinedClass clazz=cm._getClass(value);
      registry.cls().init().add(JExpr._new(clazz));
      clazz.init().add(registry.cls().staticInvoke("instance").invoke("getFormatCodeMap").invoke("put").arg(clazz.fields().get("NUMERIC_ID")).arg(clazz.dotclass()));
      clazz.init().add(registry.cls().staticInvoke("instance").invoke("getSymbolicCodeMap").invoke("put").arg(clazz.fields().get("SYMBOLIC_ID")).arg(clazz.dotclass()));
    }
    generateDefinitions();
    cm.build(outputDirectory);
  }
 catch (  Exception e) {
    Log.error("Error generating code : %s",e);
    for (    StackTraceElement s : e.getStackTrace()) {
      Log.error("\tat %s.%s(%s:%s)",s.getClassName(),s.getMethodName(),s.getFileName(),s.getLineNumber());
    }
    throw e;
  }
}
