{
  final MqttProtocolDecoder h=new MqttProtocolDecoder(this);
  h.errorHandler(new Handler<String>(){
    @Override public void handle(    String error){
      LOG.info("STOMP protocol decoding error: " + error);
      socket.close();
    }
  }
);
  h.codecHandler(new Handler<MQTTFrame>(){
    @Override public void handle(    MQTTFrame event){
      try {
        if (event.messageType() == org.fusesource.mqtt.codec.CONNECT.TYPE) {
          CONNECT connect=new CONNECT().decode(event);
          ConnectionParameters parameters=new ConnectionParameters();
          if (connect.clientId() != null) {
            parameters.protocolClientId=connect.clientId().toString();
          }
          if (connect.userName() != null) {
            parameters.protocolUser=connect.userName().toString();
            if (parameters.protocolUser.contains("/")) {
              String[] parts=parameters.protocolUser.split("/",2);
              parameters.protocolVirtualHost=parts[0];
              parameters.protocolUser=parts[1];
              connect.userName(new UTF8Buffer(parameters.protocolUser));
              Buffer tail=received.getBuffer((int)h.getBytesDecoded(),received.length());
              BufferSupport.setLength(received,0);
              append(received,connect.encode());
              received.appendBuffer(tail);
            }
          }
          handler.handle(parameters);
        }
 else {
          LOG.info("Expected a CONNECT frame");
          socket.close();
        }
      }
 catch (      java.net.ProtocolException e) {
        LOG.info("Invalid MQTT frame: " + e,e);
        socket.close();
      }
    }
  }
);
  socket.readStream().dataHandler(h);
  h.handle(received);
}
