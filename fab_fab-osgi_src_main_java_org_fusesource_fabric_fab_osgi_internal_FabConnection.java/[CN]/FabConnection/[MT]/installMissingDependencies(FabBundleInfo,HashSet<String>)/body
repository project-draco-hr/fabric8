{
  BundleContext bundleContext=getBundleContext();
  if (bundleContext == null) {
    LOG.warn("No BundleContext available so cannot install provided dependencies");
  }
 else {
    for (    DependencyTree dependency : info.getBundles()) {
      if (dependency.isBundle()) {
        String importPackages=dependency.getManifestEntry(Analyzer.IMPORT_PACKAGE);
        if (notEmpty(importPackages)) {
          Map<String,Map<String,String>> values=new Analyzer().parseHeader(importPackages);
          for (          Map.Entry<String,Map<String,String>> entry : values.entrySet()) {
            String res=entry.getValue().get("resolution:");
            if (!"optional".equals(res)) {
              actualImports.add(entry.getKey());
            }
          }
        }
      }
    }
    for (    DependencyTree dependency : info.getBundles()) {
      String name=dependency.getBundleSymbolicName();
      String version=dependency.getVersion();
      if (Bundles.isInstalled(bundleContext,name,version)) {
        LOG.info("Bundle already installed: " + name + " ("+ version+ ")");
      }
 else {
        HashSet<String> p=new HashSet<String>(dependency.getPackages());
        p.retainAll(actualImports);
        Set<String> missing=Bundles.filterInstalled(bundleContext,p,(VersionResolver)info);
        boolean hasNoPendingPackagesOrServices=false;
        if (missing.isEmpty()) {
          Set<Service> services=Services.parseHeader(dependency.getManifestEntry("Export-Service"));
          if (services.isEmpty() || Services.isAvailable(bundleContext,services)) {
            hasNoPendingPackagesOrServices=true;
          }
 else           if (Services.isAvailable(bundleContext,services)) {
            LOG.info("Bundle non-optional packages already installed for: " + name + " version: "+ version+ " but it exposes services that are not currently available so will install: "+ services);
          }
        }
        if (hasNoPendingPackagesOrServices) {
          LOG.info("Bundle non-optional packages already installed for: " + name + " version: "+ version+ " packages: "+ p);
        }
 else {
          LOG.info("Packages not yet shared: " + missing);
          URL url=dependency.getJarURL();
          String installUri=url.toExternalForm();
          try {
            Bundle bundle=null;
            if (!dependency.isBundle()) {
              FabConnection childConnection=createChild(url);
              PomDetails pomDetails=childConnection.resolver.getInfo().getPomDetails();
              if (pomDetails != null && pomDetails.isValid()) {
                LOG.info("Installing fabric bundle: " + name + " from: "+ installUri);
                bundle=bundleContext.installBundle(installUri,childConnection.getInputStream());
              }
 else {
                LOG.warn("Could not deduce the pom.xml for the jar " + installUri + " so cannot treat as FAB");
              }
            }
 else {
              LOG.info("Installing bundle: " + name + " from: "+ installUri);
              bundle=bundleContext.installBundle(installUri);
            }
          }
 catch (          BundleException e) {
            LOG.error("Failed to deploy " + installUri + " due to error: "+ e,e);
            throw e;
          }
catch (          IOException e) {
            LOG.error("Failed to deploy " + installUri + " due to error: "+ e,e);
            throw e;
          }
catch (          RuntimeException e) {
            LOG.error("Failed to deploy " + installUri + " due to error: "+ e,e);
            throw e;
          }
        }
      }
    }
  }
}
