{
  List<String> fullPaths=Lists.newArrayList(Lists.transform(children,new Function<String,String>(){
    @Override public String apply(    String child){
      return ZKPaths.makePath(path,child);
    }
  }
));
  Set<String> removedNodes=Sets.filter(Sets.newHashSet(currentData.keySet()),new Predicate<String>(){
    @Override public boolean apply(    String input){
      if (input.matches(String.format(CHILD_OF_ZNODE_PATTERN,path))) {
        return true;
      }
 else {
        return false;
      }
    }
  }
);
  removedNodes.removeAll(fullPaths);
  for (  String fullPath : removedNodes) {
    remove(fullPath);
  }
  for (  String name : children) {
    String fullPath=ZKPaths.makePath(path,name);
    if ((mode == RefreshMode.FORCE_GET_DATA_AND_STAT) || !currentData.containsKey(fullPath)) {
      getDataAndStat(fullPath);
    }
    updateInitialSet(name,NULL_CHILD_DATA);
    offerOperation(new TreeRefreshOperation(this,fullPath,mode));
  }
  maybeOfferInitializedEvent(initialSet.get());
}
