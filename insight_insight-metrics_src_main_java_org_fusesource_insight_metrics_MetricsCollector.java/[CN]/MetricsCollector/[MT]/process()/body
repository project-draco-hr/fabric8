{
  try {
    Container container=fabricService.getCurrentContainer();
    if (container != null) {
      Set<Query> newQueries=new HashSet<Query>();
      Profile[] profiles=container.getProfiles();
      if (profiles != null) {
        for (        Profile profile : profiles) {
          loadProfile(profile,newQueries);
        }
      }
      for (      Query q : queries.keySet()) {
        if (!newQueries.remove(q)) {
          queries.remove(q).close();
        }
      }
      Server server=new Server(container.getId());
      for (      Query q : newQueries) {
        final String queryName=q.getName();
        final String containerName=container.getId();
        final QueryState state=new QueryState();
        state.server=server;
        state.query=q;
        if (q.getMetadata() != null) {
          state.metadata=parseJson(loadFully(new URL(q.getMetadata())));
        }
        if (q.getLock() != null) {
          state.lock=new ClusteredSingleton<QueryNodeState>(QueryNodeState.class);
          state.lock.add(new ChangeListener(){
            @Override public void changed(){
              try {
                state.lock.update(new QueryNodeState(queryName,containerName,state.lock.isMaster() ? new String[]{"stat"} : null));
              }
 catch (              IllegalStateException e) {
              }
            }
            @Override public void connected(){
            }
            @Override public void disconnected(){
            }
          }
);
          state.lock.start(startGroup(q.getLock()));
          state.lock.join(new QueryNodeState(queryName,containerName,null));
        }
        long delay=q.getPeriod() > 0 ? q.getPeriod() : defaultDelay;
        state.future=this.executor.scheduleAtFixedRate(new Task(state),Math.round(Math.random() * 1000) + 1,delay * 1000,TimeUnit.MILLISECONDS);
        queries.put(q,state);
      }
    }
  }
 catch (  RejectedExecutionException t) {
  }
catch (  Throwable t) {
    LOG.warn("Error while starting metrics",t);
  }
}
