{
  final SimpleDiscoveryEvent event=(SimpleDiscoveryEvent)devent;
  if (event.failed.compareAndSet(false,true)) {
    discoveryListener.get().onServiceRemove(event);
    if (!event.removed.get()) {
      Thread thread=new Thread(){
        public void run(){
          if (event.connectTime + minConnectTime > System.currentTimeMillis()) {
            LOG.debug("Failure occurred soon after the discovery event was generated.  It will be classified as a connection failure: " + event);
            event.connectFailures++;
            if (maxReconnectAttempts > 0 && event.connectFailures >= maxReconnectAttempts) {
              LOG.debug("Reconnect attempts exceeded " + maxReconnectAttempts + " tries.  Reconnecting has been disabled.");
              return;
            }
synchronized (sleepMutex) {
              try {
                if (!running.get() || event.removed.get()) {
                  return;
                }
                LOG.debug("Waiting " + event.reconnectDelay + " ms before attempting to reconnect.");
                sleepMutex.wait(event.reconnectDelay);
              }
 catch (              InterruptedException ie) {
                Thread.currentThread().interrupt();
                return;
              }
            }
            if (!useExponentialBackOff) {
              event.reconnectDelay=initialReconnectDelay;
            }
 else {
              event.reconnectDelay*=backOffMultiplier;
              if (event.reconnectDelay > maxReconnectDelay) {
                event.reconnectDelay=maxReconnectDelay;
              }
            }
          }
 else {
            event.connectFailures=0;
            event.reconnectDelay=initialReconnectDelay;
          }
          if (!running.get() || event.removed.get()) {
            return;
          }
          event.connectTime=System.currentTimeMillis();
          event.failed.set(false);
          discoveryListener.get().onServiceAdd(event);
        }
      }
;
      thread.setDaemon(true);
      thread.start();
    }
  }
}
