{
  clientResponse.pause();
  final ServiceResponse serviceResponse=new ServiceResponse();
  serviceResponse.setCode(clientResponse.statusCode());
  serviceResponse.setMessage(clientResponse.statusMessage());
  serviceResponse.setAttribute(ApiManService.ATTR_CLIENT_RESPONSE,clientResponse);
  serviceResponse.setAttribute(ApiManService.ATTR_HTTP_CLIENT,httpClient);
  Map<String,String> headerMap=new HashMap<String,String>();
  for (  String key : clientResponse.headers().names()) {
    headerMap.put(key,clientResponse.headers().get(key));
  }
  serviceResponse.setHeaders(headerMap);
  final IServiceConnectionResponse streamToClient=new IServiceConnectionResponse(){
    private boolean streamFinished=false;
    @Override public void transmit(){
      clientResponse.resume();
    }
    @Override public ServiceResponse getHead(){
      return serviceResponse;
    }
    @Override public void abort(){
    }
    @Override public void bodyHandler(    final IAsyncHandler<IApimanBuffer> bodyHandler){
      clientResponse.dataHandler(new Handler<Buffer>(){
        @Override public void handle(        Buffer chunk){
          bodyHandler.handle(new VertxBuffer(chunk));
        }
      }
);
    }
    @Override public void endHandler(    final IAsyncHandler<Void> endHandler){
      clientResponse.endHandler(new VoidHandler(){
        @Override protected void handle(){
          streamFinished=true;
          endHandler.handle(null);
        }
      }
);
    }
    @Override public boolean isFinished(){
      return streamFinished;
    }
  }
;
  IAsyncResult<IServiceConnectionResponse> result=AsyncResultImpl.<IServiceConnectionResponse>create(streamToClient);
  apiManServiceResponseHandler.handle(result);
}
