{
  String remoteName="origin";
  try {
    git.fetch().setCredentialsProvider(credentialsProvider).setRemote(remoteName).call();
  }
 catch (  Exception e) {
    return;
  }
  Map<String,Ref> localBranches=new HashMap<String,Ref>();
  Map<String,Ref> remoteBranches=new HashMap<String,Ref>();
  Set<String> gitVersions=new HashSet<String>();
  for (  Ref ref : git.branchList().setListMode(ListBranchCommand.ListMode.ALL).call()) {
    if (ref.getName().startsWith("refs/remotes/" + remoteName + "/")) {
      String name=ref.getName().substring(("refs/remotes/" + remoteName + "/").length());
      if (!"master".equals(name) && !name.endsWith("-tmp")) {
        remoteBranches.put(name,ref);
        gitVersions.add(name);
      }
    }
 else     if (ref.getName().startsWith("refs/heads/")) {
      String name=ref.getName().substring(("refs/heads/").length());
      if (!name.equals("master") && !name.endsWith("-tmp")) {
        localBranches.put(name,ref);
        gitVersions.add(name);
      }
    }
  }
  for (  String version : gitVersions) {
    String localCommit=localBranches.get(version).getObjectId().getName();
    String remoteCommit=remoteBranches.get(version).getObjectId().getName();
    if (!localCommit.equals(remoteCommit)) {
      git.clean().setCleanDirectories(true).call();
      git.checkout().setName("HEAD").setForce(true).call();
      git.checkout().setName(version).setForce(true).call();
      MergeResult result=git.merge().setStrategy(MergeStrategy.THEIRS).include(remoteBranches.get(version).getObjectId()).call();
    }
  }
}
