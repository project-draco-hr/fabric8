{
  String remoteName="origin";
  boolean remoteAvailable=false;
  try {
    git.fetch().setCredentialsProvider(credentialsProvider).setRemote(remoteName).call();
    remoteAvailable=true;
  }
 catch (  Exception e) {
    if (LOGGER.isTraceEnabled()) {
      LOGGER.trace("Unable to fetch master",e);
    }
 else     if (LOGGER.isDebugEnabled()) {
      LOGGER.debug("Unable to fetch master: " + e.getClass().getName() + ": "+ e.getMessage());
    }
  }
  Map<String,Ref> localBranches=new HashMap<String,Ref>();
  Map<String,Ref> remoteBranches=new HashMap<String,Ref>();
  Set<String> gitVersions=new HashSet<String>();
  for (  Ref ref : git.branchList().setListMode(ListBranchCommand.ListMode.ALL).call()) {
    if (ref.getName().startsWith("refs/remotes/" + remoteName + "/")) {
      String name=ref.getName().substring(("refs/remotes/" + remoteName + "/").length());
      if (!"master".equals(name) && !name.endsWith("-tmp")) {
        remoteBranches.put(name,ref);
        gitVersions.add(name);
      }
    }
 else     if (ref.getName().startsWith("refs/heads/")) {
      String name=ref.getName().substring(("refs/heads/").length());
      if (!name.equals("master") && !name.endsWith("-tmp")) {
        localBranches.put(name,ref);
        gitVersions.add(name);
      }
    }
  }
  List<String> zkVersions=getChildren(zookeeper,ZkPath.CONFIG_VERSIONS.getPath());
  createDefault(zookeeper,"/fabric/configs/git",null);
  Properties versionsMetadata=loadProps(zookeeper,"/fabric/configs/git");
  boolean allDone=true;
  String lastModified=Long.toString(lastModified(zookeeper,ZkPath.CONFIG_VERSIONS.getPath()));
  if (!lastModified.equals(versionsMetadata.get("zk-lastmodified"))) {
    allDone=false;
  }
  if (zkVersions.size() != gitVersions.size() || !zkVersions.containsAll(gitVersions)) {
    allDone=false;
  }
  if (gitVersions.size() != localBranches.size() || !localBranches.keySet().containsAll(gitVersions)) {
    allDone=false;
  }
  if (remoteAvailable && !remoteBranches.keySet().containsAll(gitVersions)) {
    allDone=false;
  }
  if (allDone) {
    for (    String version : zkVersions) {
      String zkCommit=versionsMetadata.get(version);
      String localCommit=localBranches.get(version).getObjectId().getName();
      String remoteCommit=remoteAvailable ? remoteBranches.get(version).getObjectId().getName() : null;
      if (!localCommit.equals(zkCommit) || remoteCommit != null && !localCommit.equals(remoteCommit)) {
        allDone=false;
        break;
      }
    }
  }
  if (allDone) {
    return;
  }
  for (  String version : zkVersions) {
    String zkNode=ZkPath.CONFIG_VERSION.getPath(version);
    List<Ref> allBranches=git.branchList().setListMode(ListBranchCommand.ListMode.ALL).call();
    Ref local=null;
    Ref remote=null;
    Ref tmp=null;
    for (    Ref ref : allBranches) {
      if (ref.getName().equals("refs/remotes/" + remoteName + "/"+ version)) {
        remote=ref;
      }
 else       if (ref.getName().equals("refs/heads/" + version)) {
        local=ref;
      }
 else       if (ref.getName().equals("refs/heads/" + version + "-tmp")) {
        tmp=ref;
      }
    }
    if (local == null) {
      git.branchCreate().setName(version).call();
    }
    if (tmp == null) {
      git.branchCreate().setName(version + "-tmp").call();
    }
    git.clean().setCleanDirectories(true).call();
    git.checkout().setName("HEAD").setForce(true).call();
    git.checkout().setName(version).setForce(true).call();
    if (remoteAvailable && remote != null) {
      MergeResult result=git.merge().setStrategy(MergeStrategy.THEIRS).include(remote.getObjectId()).call();
    }
    git.checkout().setName(version + "-tmp").setForce(true).call();
    String gitCommit=versionsMetadata.get(version);
    if (gitCommit != null) {
      try {
        git.reset().setMode(ResetCommand.ResetType.HARD).setRef(gitCommit).call();
      }
 catch (      Exception e) {
        if (LOGGER.isTraceEnabled()) {
          LOGGER.trace("Unable to reset branch to commit",e);
        }
 else         if (LOGGER.isDebugEnabled()) {
          LOGGER.debug("Unable to reset branch to commit " + gitCommit + ": "+ e.getClass().getName()+ ": "+ e.getMessage());
        }
      }
    }
    syncVersionFromZkToGit(git,zookeeper,zkNode);
    if (git.status().call().isClean()) {
      git.checkout().setName(version).setForce(true).call();
    }
 else {
      ObjectId rev=git.commit().setMessage("Merge zookeeper updates in version " + version).call().getId();
      git.checkout().setName(version).setForce(true).call();
      MergeResult result=git.merge().setStrategy(MergeStrategy.OURS).include(rev).call();
    }
    if (remoteAvailable) {
      git.push().setCredentialsProvider(credentialsProvider).setRefSpecs(new RefSpec(version)).call();
    }
    syncVersionFromGitToZk(git,zookeeper,zkNode);
    versionsMetadata.put(version,git.getRepository().getRef("HEAD").getObjectId().getName());
  }
  for (  String version : gitVersions) {
    String state=versionsMetadata.get(version);
    if (zkVersions.contains(version)) {
      continue;
    }
    if (state == null) {
      if (localBranches.containsKey(version)) {
        if (remoteAvailable) {
          git.push().setRefSpecs(new RefSpec(version)).call();
        }
      }
 else {
        git.branchCreate().setName(version).call();
        git.reset().setMode(ResetCommand.ResetType.HARD).setRef(remoteBranches.get(version).getName()).call();
      }
      git.checkout().setName(version).setForce(true).call();
      String zkNode=ZkPath.CONFIG_VERSION.getPath(version);
      create(zookeeper,zkNode);
      create(zookeeper,ZkPath.CONFIG_VERSIONS_PROFILES.getPath(version));
      create(zookeeper,ZkPath.CONFIG_VERSIONS_CONTAINERS.getPath(version));
      syncVersionFromGitToZk(git,zookeeper,zkNode);
      versionsMetadata.put(version,git.getRepository().getRef("HEAD").getObjectId().getName());
    }
 else {
      git.checkout().setName("master").setForce(true).call();
      git.branchDelete().setBranchNames(version,version + "-tmp").setForce(true).call();
      git.push().setRefSpecs(new RefSpec(version + ":")).call();
      versionsMetadata.remove(version);
    }
  }
  versionsMetadata.put("zk-lastmodified",Long.toString(lastModified(zookeeper,ZkPath.CONFIG_VERSIONS.getPath())));
  setPropertiesAsMap(zookeeper,"/fabric/configs/git",versionsMetadata);
}
