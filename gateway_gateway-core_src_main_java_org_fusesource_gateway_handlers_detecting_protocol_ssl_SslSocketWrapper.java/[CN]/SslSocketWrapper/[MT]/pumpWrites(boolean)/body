{
  boolean pump=true;
  while (pump) {
    pump=false;
    if (failed) {
      return;
    }
    if (plainWriteBuffer != null) {
      ByteBuffer input=ByteBuffer.wrap(plainWriteBuffer.getBytes());
      ByteBuffer output=ByteBuffer.allocate(engine.getSession().getPacketBufferSize());
      try {
        boolean done=false;
        while (!done) {
          done=true;
          SSLEngineResult result=engine.wrap(input,output);
switch (result.getStatus()) {
case OK:
switch (engine.getHandshakeStatus()) {
case NEED_TASK:
case NEED_UNWRAP:
              break;
default :
            done=!input.hasRemaining();
        }
      break;
case CLOSED:
    throw new SSLException("CLOSED");
case BUFFER_UNDERFLOW:
  break;
case BUFFER_OVERFLOW:
done=false;
}
output.flip();
int len=output.remaining();
if (len > 0) {
pump=true;
if (encryptedWriteBuffer == null) {
encryptedWriteBuffer=new Buffer(len);
}
encryptedWriteBuffer.appendBytes(output.array(),output.arrayOffset() + output.position(),len);
}
output.clear();
}
}
 catch (SSLException e) {
onFailure(e);
return;
}
 finally {
int len=input.remaining();
if (len > 0) {
if (input.position() != 0) {
plainWriteBuffer=new Buffer(len);
plainWriteBuffer.appendBytes(input.array(),input.arrayOffset() + input.position(),len);
}
}
 else {
plainWriteBuffer=null;
}
}
}
if (encryptedWriteBuffer != null && !writeOverflow) {
if (next.writeStream().writeQueueFull()) {
writeOverflow=true;
next.writeStream().drainHandler(drainHandler);
}
 else {
pump=true;
Buffer data=encryptedWriteBuffer;
encryptedWriteBuffer=null;
next.writeStream().write(data);
}
}
if (engine.getHandshakeStatus() != NOT_HANDSHAKING) {
if (allowHandshake) {
handshake();
}
return;
}
}
}
