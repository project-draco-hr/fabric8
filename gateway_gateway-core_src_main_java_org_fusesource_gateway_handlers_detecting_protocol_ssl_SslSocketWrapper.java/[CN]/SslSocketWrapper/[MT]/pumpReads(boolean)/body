{
  boolean pump=true;
  while (pump) {
    pump=false;
    if (readPaused > 0 || failed) {
      return;
    }
    if (encryptedReadBuffer != null && plainReadBuffer == null && !encryptedReadBufferUnderflow) {
      ByteBuffer input=ByteBuffer.wrap(encryptedReadBuffer.getBytes());
      ByteBuffer output=ByteBuffer.allocate(engine.getSession().getApplicationBufferSize());
      try {
        boolean done=false;
        while (!done) {
          done=true;
          SSLEngineResult result=engine.unwrap(input,output);
switch (result.getStatus()) {
case CLOSED:
            engine.closeInbound();
          break;
case BUFFER_UNDERFLOW:
        encryptedReadBufferUnderflow=true;
      break;
case OK:
switch (engine.getHandshakeStatus()) {
case NEED_TASK:
case NEED_WRAP:
      break;
default :
    done=!input.hasRemaining();
}
break;
case BUFFER_OVERFLOW:
throw new SSLException("BUFFER_OVERFLOW");
}
output.flip();
if (output.remaining() > 0) {
pump=true;
int len=output.remaining();
if (plainReadBuffer == null) {
plainReadBuffer=new Buffer(len);
}
plainReadBuffer.appendBytes(output.array(),output.arrayOffset() + output.position(),len);
}
output.clear();
}
}
 catch (SSLException e) {
onFailure(e);
return;
}
 finally {
int len=input.remaining();
if (len > 0) {
if (input.position() != 0) {
encryptedReadBuffer=new Buffer(len);
encryptedReadBuffer.appendBytes(input.array(),input.arrayOffset() + input.position(),len);
}
}
 else {
encryptedReadBuffer=null;
}
}
}
if (plainReadBuffer != null && readPaused == 0) {
pump=true;
Buffer data=plainReadBuffer;
plainReadBuffer=null;
Handler<Buffer> handler=plainDataHandler;
if (handler != null) {
handler.handle(data);
}
}
if (encryptedReadBuffer == null && plainReadBuffer == null && encryptedReadEOF) {
encryptedReadEOF=false;
Handler<Void> handler=plainEndHandler;
if (handler != null) {
handler.handle(null);
}
}
if (engine.getHandshakeStatus() != NOT_HANDSHAKING) {
if (allowHandshake) {
handshake();
}
return;
}
}
}
