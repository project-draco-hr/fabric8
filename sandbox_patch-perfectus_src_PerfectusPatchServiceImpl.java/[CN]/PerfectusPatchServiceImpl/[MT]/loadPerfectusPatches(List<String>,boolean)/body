{
  File cache=new File(patchDir,CACHE_FILE);
  List<String> locations=null;
  if (!reload && cache.isFile()) {
    try {
      Properties props=loadProperties(cache);
      String lastDateStr=props.getProperty(CACHE_LAST_DATE);
      if (lastDateStr != null) {
        long date=Long.parseLong(lastDateStr);
        if (System.currentTimeMillis() - date < TimeUnit.DAYS.toMillis(1)) {
          locations=new ArrayList<String>();
          int count=Integer.parseInt(props.getProperty(CACHE_LOCATION + "." + CACHE_COUNT,"0"));
          for (int i=0; i < count; i++) {
            locations.add(props.getProperty(CACHE_LOCATION + "." + Integer.toString(i)));
          }
        }
      }
    }
 catch (    Exception e) {
      LOGGER.info("Error loading patch cache.  Cache will be reset.",e);
    }
  }
  if (locations == null) {
    List<String> groups=Arrays.asList(DEFAULT_GROUPS.split(","));
    locations=findPerfectusPatchLocations(repositories,groups);
    reload=true;
  }
  Set<Patch> patches=loadPerfectusPatches(locations);
  if (reload) {
    try {
      Properties props=new Properties();
      props.setProperty(CACHE_LAST_DATE,Long.toString(System.currentTimeMillis()));
      props.setProperty(CACHE_LOCATION + "." + CACHE_COUNT,Integer.toString(locations.size()));
      for (int i=0; i < locations.size(); i++) {
        props.setProperty(CACHE_LOCATION + "." + Integer.toString(i),locations.get(i));
      }
      cache.getParentFile().mkdirs();
      FileOutputStream fos=new FileOutputStream(cache);
      try {
        props.store(fos,"Patch cache");
      }
  finally {
        close(fos);
      }
    }
 catch (    Exception e) {
      LOGGER.info("Error storing patch cache",e);
    }
  }
  return patches;
}
