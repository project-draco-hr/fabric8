{
  super.doStart();
  inputReader.execute(new Runnable(){
    @Override public void run(){
      try {
        byte batch[]=new byte[4 * 1024];
        int pos=0;
        while (isRunAllowed()) {
          if (isSuspending() || isSuspended()) {
            LOG.trace("Consumer is suspended so skip polling");
            try {
              Thread.sleep(1000);
            }
 catch (            InterruptedException e) {
              LOG.debug("Sleep interrupted, are we stopping? {}",isStopping() || isStopped());
            }
            continue;
          }
          int count=is.read(batch,pos,batch.length - pos);
          if (count < 0) {
            if (pos > 0) {
              byte[] data=new byte[pos];
              System.arraycopy(batch,0,data,0,pos);
              queue.put(data);
            }
            queue.put(EOF);
            return;
          }
 else {
            pos+=count;
            int at=lastnlposition(batch,pos);
            if (at >= 0) {
              int len=at + 1;
              byte[] data=new byte[len];
              System.arraycopy(batch,0,data,0,len);
              int remaining=pos - len;
              System.arraycopy(batch,len,batch,0,remaining);
              pos=remaining;
              queue.put(data);
            }
 else             if (pos == batch.length) {
              queue.put(batch);
              batch=new byte[4 * 1024];
              pos=0;
            }
 else {
            }
          }
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
);
  batchReader.execute(new Runnable(){
    @Override public void run(){
      boolean atEOF=false;
      while (isRunAllowed() && !atEOF) {
        if (isSuspending() || isSuspended()) {
          LOG.trace("Consumer is suspended so skip polling");
          try {
            Thread.sleep(1000);
          }
 catch (          InterruptedException e) {
            LOG.debug("Sleep interrupted, are we stopping? {}",isStopping() || isStopped());
          }
          continue;
        }
        ByteArrayOutputStream batch=new ByteArrayOutputStream((int)(batchSize * 1.5));
        try {
          Object obj=queue.poll(1000,TimeUnit.MILLISECONDS);
          if (obj != null) {
            if (obj == EOF) {
              atEOF=true;
              continue;
            }
            long start=System.currentTimeMillis();
            long timeout=start + batchTimeout;
            try {
              batch.write((byte[])obj);
              while (batch.size() < batchSize && !atEOF) {
                obj=queue.poll();
                if (obj != null) {
                  if (obj == EOF) {
                    atEOF=true;
                  }
 else {
                    batch.write((byte[])obj);
                  }
                }
 else {
                  long remaining=timeout - System.currentTimeMillis();
                  if (remaining > 0) {
                    obj=queue.poll(remaining,TimeUnit.MILLISECONDS);
                    if (obj != null) {
                      if (obj == EOF) {
                        atEOF=true;
                      }
 else {
                        batch.write((byte[])obj);
                      }
                      continue;
                    }
                  }
                  break;
                }
              }
              if (batch.size() > 0) {
                byte[] body=batch.toByteArray();
                batch.reset();
                Exchange exchange=getEndpoint().createExchange();
                Message msg=new DefaultMessage();
                msg.setBody(body);
                exchange.setIn(msg);
                try {
                  getProcessor().process(exchange);
                  if (exchange.getException() != null) {
                    getExceptionHandler().handleException("Error processing exchange",exchange,exchange.getException());
                  }
                }
 catch (                Exception e) {
                  getExceptionHandler().handleException("Error processing exchange",exchange,e);
                }
              }
            }
 catch (            Exception e) {
              LOG.info("Error processing exchange.",e);
            }
          }
        }
 catch (        InterruptedException e) {
          LOG.debug("Sleep interrupted, are we stopping? {}",isStopping() || isStopped());
          continue;
        }
      }
      if (atEOF && isRunAllowed()) {
        Exchange exchange=getEndpoint().createExchange();
        Message msg=new DefaultMessage();
        msg.setHeader("EOF","true");
        msg.setBody(new byte[0]);
        exchange.setIn(msg);
        try {
          getProcessor().process(exchange);
          if (exchange.getException() != null) {
            getExceptionHandler().handleException("Error processing exchange",exchange,exchange.getException());
          }
        }
 catch (        Exception e) {
          getExceptionHandler().handleException("Error processing exchange",exchange,e);
        }
        System.exit(0);
      }
    }
  }
);
}
