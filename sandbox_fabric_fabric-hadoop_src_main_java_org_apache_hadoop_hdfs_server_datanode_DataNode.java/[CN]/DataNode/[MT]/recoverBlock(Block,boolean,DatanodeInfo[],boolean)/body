{
synchronized (ongoingRecovery) {
    if (ongoingRecovery.get(block.getWithWildcardGS()) != null) {
      String msg=block + " is already being recovered, " + " ignoring this request to recover it.";
      LOG.info(msg);
      throw new IOException(msg);
    }
    ongoingRecovery.put(block,block);
  }
  try {
    int errorCount=0;
    int rbwCount=0;
    int rwrCount=0;
    List<BlockRecord> blockRecords=new ArrayList<BlockRecord>();
    for (    DatanodeInfo id : targets) {
      try {
        InterDatanodeProtocol datanode=dnRegistration.equals(id) ? this : DataNode.createInterDataNodeProtocolProxy(id,getConf(),socketTimeout,connectToDnViaHostname);
        BlockRecoveryInfo info=datanode.startBlockRecovery(block);
        if (info == null) {
          LOG.info("No block metadata found for " + block + " on datanode "+ id);
          continue;
        }
        if (info.getBlock().getGenerationStamp() < block.getGenerationStamp()) {
          LOG.info("Only old generation stamp " + info.getBlock().getGenerationStamp() + " found on datanode "+ id+ " (needed block="+ block+ ")");
          continue;
        }
        blockRecords.add(new BlockRecord(id,datanode,info));
        if (info.wasRecoveredOnStartup()) {
          rwrCount++;
        }
 else {
          rbwCount++;
        }
      }
 catch (      IOException e) {
        ++errorCount;
        InterDatanodeProtocol.LOG.warn("Failed to getBlockMetaDataInfo for block (=" + block + ") from datanode (="+ id+ ")",e);
      }
    }
    boolean shouldRecoverRwrs=(rbwCount == 0);
    List<BlockRecord> syncList=new ArrayList<BlockRecord>();
    long minlength=Long.MAX_VALUE;
    for (    BlockRecord record : blockRecords) {
      BlockRecoveryInfo info=record.info;
      assert(info != null && info.getBlock().getGenerationStamp() >= block.getGenerationStamp());
      if (!shouldRecoverRwrs && info.wasRecoveredOnStartup()) {
        LOG.info("Not recovering replica " + record + " since it was recovered on "+ "startup and we have better replicas");
        continue;
      }
      if (keepLength) {
        if (info.getBlock().getNumBytes() == block.getNumBytes()) {
          syncList.add(record);
        }
      }
 else {
        syncList.add(record);
        if (info.getBlock().getNumBytes() < minlength) {
          minlength=info.getBlock().getNumBytes();
        }
      }
    }
    if (syncList.isEmpty() && errorCount > 0) {
      throw new IOException("All datanodes failed: block=" + block + ", datanodeids="+ Arrays.asList(targets));
    }
    if (!keepLength) {
      block.setNumBytes(minlength);
    }
    return syncBlock(block,syncList,targets,closeFile);
  }
  finally {
synchronized (ongoingRecovery) {
      ongoingRecovery.remove(block);
    }
  }
}
