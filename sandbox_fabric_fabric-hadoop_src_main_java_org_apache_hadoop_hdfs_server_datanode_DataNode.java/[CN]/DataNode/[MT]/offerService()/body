{
  LOG.info("using BLOCKREPORT_INTERVAL of " + blockReportInterval + "msec"+ " Initial delay: "+ initialBlockReportDelay+ "msec");
  while (shouldRun) {
    try {
      long startTime=now();
      if (startTime - lastHeartbeat > heartBeatInterval) {
        lastHeartbeat=startTime;
        DatanodeCommand[] cmds=namenode.sendHeartbeat(dnRegistration,data.getCapacity(),data.getDfsUsed(),data.getRemaining(),xmitsInProgress.get(),getXceiverCount());
        myMetrics.addHeartBeat(now() - startTime);
        if (!processCommand(cmds))         continue;
      }
      Block[] blockArray=null;
      String[] delHintArray=null;
synchronized (receivedBlockList) {
synchronized (delHints) {
          int numBlocks=receivedBlockList.size();
          if (numBlocks > 0) {
            if (numBlocks != delHints.size()) {
              LOG.warn("Panic: receiveBlockList and delHints are not of the same length");
            }
            blockArray=receivedBlockList.toArray(new Block[numBlocks]);
            delHintArray=delHints.toArray(new String[numBlocks]);
          }
        }
      }
      if (blockArray != null) {
        if (delHintArray == null || delHintArray.length != blockArray.length) {
          LOG.warn("Panic: block array & delHintArray are not the same");
        }
        namenode.blockReceived(dnRegistration,blockArray,delHintArray);
synchronized (receivedBlockList) {
synchronized (delHints) {
            for (int i=0; i < blockArray.length; i++) {
              receivedBlockList.remove(blockArray[i]);
              delHints.remove(delHintArray[i]);
            }
          }
        }
      }
      if (startTime - lastBlockReport > blockReportInterval) {
        if (data.isAsyncBlockReportReady()) {
          long brCreateStartTime=now();
          Block[] bReport=data.retrieveAsyncBlockReport();
          long brSendStartTime=now();
          DatanodeCommand cmd=namenode.blockReport(dnRegistration,BlockListAsLongs.convertToArrayLongs(bReport));
          long brSendCost=now() - brSendStartTime;
          long brCreateCost=brSendStartTime - brCreateStartTime;
          myMetrics.addBlockReport(brSendCost);
          LOG.info("BlockReport of " + bReport.length + " blocks took "+ brCreateCost+ " msec to generate and "+ brSendCost+ " msecs for RPC and NN processing");
          if (resetBlockReportTime) {
            lastBlockReport=startTime - R.nextInt((int)(blockReportInterval));
            resetBlockReportTime=false;
          }
 else {
            lastBlockReport+=(now() - lastBlockReport) / blockReportInterval * blockReportInterval;
          }
          processCommand(cmd);
        }
 else {
          data.requestAsyncBlockReport();
          if (lastBlockReport > 0) {
            long waitingFor=startTime - lastBlockReport - blockReportInterval;
            String msg="Block report is due, and been waiting for it for " + (waitingFor / 1000) + " seconds...";
            if (waitingFor > LATE_BLOCK_REPORT_WARN_THRESHOLD) {
              LOG.warn(msg);
            }
 else             if (waitingFor > LATE_BLOCK_REPORT_INFO_THRESHOLD) {
              LOG.info(msg);
            }
 else             if (LOG.isDebugEnabled()) {
              LOG.debug(msg);
            }
          }
        }
      }
      if (blockScanner != null && blockScannerThread == null && upgradeManager.isUpgradeCompleted()) {
        LOG.info("Starting Periodic block scanner");
        blockScannerThread=new Daemon(blockScanner);
        blockScannerThread.start();
      }
      long waitTime=heartBeatInterval - (System.currentTimeMillis() - lastHeartbeat);
synchronized (receivedBlockList) {
        if (waitTime > 0 && receivedBlockList.size() == 0) {
          try {
            receivedBlockList.wait(waitTime);
          }
 catch (          InterruptedException ie) {
          }
          delayBeforeBlockReceived();
        }
      }
    }
 catch (    RemoteException re) {
      String reClass=re.getClassName();
      if (UnregisteredDatanodeException.class.getName().equals(reClass) || DisallowedDatanodeException.class.getName().equals(reClass) || IncorrectVersionException.class.getName().equals(reClass)) {
        LOG.warn("DataNode is shutting down: " + StringUtils.stringifyException(re));
        shutdown();
        return;
      }
      LOG.warn(StringUtils.stringifyException(re));
    }
catch (    IOException e) {
      LOG.warn(StringUtils.stringifyException(e));
    }
  }
}
