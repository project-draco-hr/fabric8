{
  Set<ContainerProxy> containers=new HashSet<ContainerProxy>();
  BundleContext bundleContext=getBundleContext();
  ServiceLocator.awaitService(getBundleContext(),FabricComplete.class);
  FabricService fabricService=fabricServiceServiceProxy.getService();
  CompletionService<Set<ContainerProxy>> completionService=new ExecutorCompletionService<Set<ContainerProxy>>(executorService);
  int tasks=0;
  for (  B builder : buildersList) {
    builder.profiles(profileNames);
    if (!builder.isEnsembleServer()) {
      builder.zookeeperUrl(fabricService.getZookeeperUrl());
      CreateContainerBasicOptions options=builder.build();
      ServiceLocator.awaitService(bundleContext,ContainerProvider.class,"(fabric.container.protocol=" + options.getProviderType() + ")",CREATE_TIMEOUT,TimeUnit.MILLISECONDS);
      completionService.submit(new CreateContainerTask(fabricServiceServiceProxy,options));
      tasks++;
    }
  }
  try {
    for (int i=0; i < tasks; i++) {
      Future<Set<ContainerProxy>> futureContainerSet=completionService.poll(CREATE_TIMEOUT,TimeUnit.MILLISECONDS);
      Set<ContainerProxy> containerSet=futureContainerSet.get();
      containers.addAll(containerSet);
    }
    try {
      if (waitForProvisioning) {
        Provision.containerStatus(containers,provisionTimeOut);
      }
      if (assertProvisioningResult) {
        Provision.provisioningSuccess(containers,provisionTimeOut,ContainerCallback.DISPLAY_ALL);
      }
    }
 catch (    Exception e) {
      throw FabricException.launderThrowable(e);
    }
  }
 catch (  Exception e) {
    throw FabricException.launderThrowable(e);
  }
  return Collections.unmodifiableSet(containers);
}
