{
  Repository repository=git.getRepository();
  StoredConfig config=repository.getConfig();
  String remoteUrl=config.getString("remote",remoteRef,"url");
  if (remoteUrl == null) {
    LOGGER.debug("No remote repository defined, so not doing a pull");
    return new AbstractPullPolicyResult();
  }
  LOGGER.info("Performing a pull on remote URL: {}",remoteUrl);
  Exception lastException=null;
  try {
    git.fetch().setTimeout(gitTimeout).setCredentialsProvider(credentialsProvider).setRemote(remoteRef).call();
  }
 catch (  GitAPIException|JGitInternalException ex) {
    lastException=ex;
  }
  if (lastException != null) {
    LOGGER.warn("Pull failed because of: {}",lastException.toString());
    return new AbstractPullPolicyResult(lastException);
  }
  Map<String,Ref> localBranches=new HashMap<String,Ref>();
  Map<String,Ref> remoteBranches=new HashMap<String,Ref>();
  Set<String> allBranches=new HashSet<String>();
  try {
    for (    Ref ref : git.branchList().setListMode(ListBranchCommand.ListMode.ALL).call()) {
      if (ref.getName().startsWith("refs/remotes/" + remoteRef + "/")) {
        String name=ref.getName().substring(("refs/remotes/" + remoteRef + "/").length());
        remoteBranches.put(name,ref);
        allBranches.add(name);
      }
 else       if (ref.getName().startsWith("refs/heads/")) {
        String name=ref.getName().substring(("refs/heads/").length());
        localBranches.put(name,ref);
        allBranches.add(name);
      }
    }
    boolean localUpdate=false;
    boolean remoteUpdate=false;
    Set<String> versions=new TreeSet<>();
    if (remoteBranches.isEmpty()) {
      LOGGER.debug("Pulled from an empty remote repository");
      return new AbstractPullPolicyResult(versions,false,!localBranches.isEmpty(),null);
    }
 else {
      LOGGER.debug("Processing remote branches: {}",remoteBranches);
    }
    IllegalStateAssertion.assertTrue(remoteBranches.containsKey(GitHelpers.MASTER_BRANCH),"Remote repository does not have a master branch");
    if (localBranches.containsKey(GitHelpers.MASTER_BRANCH)) {
      git.checkout().setName(GitHelpers.MASTER_BRANCH).setForce(true).call();
    }
    for (    String branch : allBranches) {
      boolean allowDelete=allowVersionDelete && !GitHelpers.MASTER_BRANCH.equals(branch);
      if (localBranches.containsKey(branch) && !remoteBranches.containsKey(branch)) {
        if (allowDelete) {
          LOGGER.debug("Deleting local branch: {}",branch);
          git.branchDelete().setBranchNames(branch).setForce(true).call();
          localUpdate=true;
        }
 else {
          remoteUpdate=true;
        }
      }
 else       if (!localBranches.containsKey(branch) && remoteBranches.containsKey(branch)) {
        LOGGER.debug("Adding local branch: {}",branch);
        git.checkout().setCreateBranch(true).setName(branch).setStartPoint(remoteRef + "/" + branch).setUpstreamMode(SetupUpstreamMode.TRACK).setForce(true).call();
        versions.add(branch);
        localUpdate=true;
      }
 else       if (localBranches.containsKey(branch) && remoteBranches.containsKey(branch)) {
        ObjectId localObjectId=localBranches.get(branch).getObjectId();
        ObjectId remoteObjectId=remoteBranches.get(branch).getObjectId();
        String localCommit=localObjectId.getName();
        String remoteCommit=remoteObjectId.getName();
        if (!localCommit.equals(remoteCommit)) {
          git.clean().setCleanDirectories(true).call();
          git.checkout().setName("HEAD").setForce(true).call();
          git.checkout().setName(branch).setForce(true).call();
          MergeResult mergeResult=git.merge().setFastForward(FastForwardMode.FF_ONLY).include(remoteObjectId).call();
          MergeStatus mergeStatus=mergeResult.getMergeStatus();
          LOGGER.debug("Updating local branch {} with status: {}",branch,mergeStatus);
          if (mergeStatus == MergeStatus.FAST_FORWARD) {
            localUpdate=true;
          }
 else           if (mergeStatus == MergeStatus.ALREADY_UP_TO_DATE) {
            remoteUpdate=true;
          }
 else           if (mergeStatus == MergeStatus.ABORTED) {
            LOGGER.debug("Cannot fast forward branch {}, attempting rebase",branch);
            RebaseResult rebaseResult=git.rebase().setUpstream(remoteCommit).call();
            RebaseResult.Status rebaseStatus=rebaseResult.getStatus();
            if (rebaseStatus == RebaseResult.Status.OK) {
              localUpdate=true;
              remoteUpdate=true;
            }
 else {
              LOGGER.warn("Rebase on branch {} failed, restoring remote branch",branch);
              git.rebase().setOperation(Operation.ABORT).call();
              git.checkout().setName(GitHelpers.MASTER_BRANCH).setForce(true).call();
              git.branchDelete().setBranchNames(branch).setForce(true).call();
              git.checkout().setCreateBranch(true).setName(branch).setStartPoint(remoteRef + "/" + branch).setUpstreamMode(SetupUpstreamMode.TRACK).setForce(true).call();
              localUpdate=true;
            }
          }
        }
        versions.add(branch);
      }
    }
    PullPolicyResult result=new AbstractPullPolicyResult(versions,localUpdate,remoteUpdate,null);
    LOGGER.info("Pull result: {}",result);
    return result;
  }
 catch (  Exception ex) {
    return new AbstractPullPolicyResult(ex);
  }
}
