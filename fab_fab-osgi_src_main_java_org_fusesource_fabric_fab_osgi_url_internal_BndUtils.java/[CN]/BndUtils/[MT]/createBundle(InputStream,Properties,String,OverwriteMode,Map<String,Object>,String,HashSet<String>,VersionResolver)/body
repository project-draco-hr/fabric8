{
  NullArgumentException.validateNotNull(jarInputStream,"Jar URL");
  NullArgumentException.validateNotNull(instructions,"Instructions");
  NullArgumentException.validateNotEmpty(jarInfo,"Jar info");
  LOG.debug("Creating bundle for [" + jarInfo + "]");
  LOG.debug("Overwrite mode: " + overwriteMode);
  LOG.trace("Using instructions " + instructions);
  final Jar jar=new Jar("dot",jarInputStream);
  final Manifest manifest=jar.getManifest();
  if (manifest == null || OverwriteMode.KEEP != overwriteMode || (manifest.getMainAttributes().getValue(Analyzer.EXPORT_PACKAGE) == null && manifest.getMainAttributes().getValue(Analyzer.IMPORT_PACKAGE) == null)) {
    final Properties properties=new Properties();
    properties.putAll(instructions);
    properties.put("Generated-By-Fabric-From",jarInfo);
    final Analyzer analyzer=new Analyzer();
    analyzer.setJar(jar);
    analyzer.setProperties(properties);
    for (    Map.Entry<String,Object> entry : embeddedResources.entrySet()) {
      String path=entry.getKey();
      Object value=entry.getValue();
      Resource resource=toResource(value);
      if (resource != null) {
        jar.putResource(path,resource);
        try {
          File file=toFile(value);
          analyzer.addClasspath(file);
        }
 catch (        IOException e) {
          LOG.warn("Failed to get File for " + value + ". "+ e,e);
        }
      }
    }
    if (manifest != null && OverwriteMode.MERGE == overwriteMode) {
      analyzer.mergeManifest(manifest);
    }
    checkMandatoryProperties(analyzer,jar,jarInfo);
    analyzer.calcManifest();
    Attributes main=jar.getManifest().getMainAttributes();
    String importPackages=emptyIfNull(main.getValue(Analyzer.IMPORT_PACKAGE));
    Map<String,Map<String,String>> values=new Analyzer().parseHeader(importPackages);
    if (notEmpty(extraImportPackages)) {
      Map<String,Map<String,String>> extra=new Analyzer().parseHeader(extraImportPackages);
      for (      Map.Entry<String,Map<String,String>> entry : extra.entrySet()) {
        Map<String,String> original=values.get(entry.getKey());
        if (original == null) {
          original=entry.getValue();
        }
 else {
          original.putAll(entry.getValue());
        }
        values.put(entry.getKey(),original);
      }
    }
    if (versionResolver != null) {
      for (      Map.Entry<String,Map<String,String>> entry : values.entrySet()) {
        String packageName=entry.getKey();
        Map<String,String> packageValues=entry.getValue();
        if (!packageValues.containsKey("version")) {
          String version=versionResolver.resolvePackage(packageName);
          if (version != null) {
            packageValues.put("version",version);
          }
        }
      }
    }
    importPackages=Processor.printClauses(values,ALLOWED_PACKAGE_CLAUSES);
    for (    Map.Entry<String,Map<String,String>> entry : values.entrySet()) {
      String res=entry.getValue().get("resolution:");
      if (!"optional".equals(res)) {
        actualImports.add(entry.getKey());
      }
    }
    if (notEmpty(importPackages)) {
      main.putValue(Analyzer.IMPORT_PACKAGE,importPackages);
    }
  }
  return createInputStream(jar);
}
