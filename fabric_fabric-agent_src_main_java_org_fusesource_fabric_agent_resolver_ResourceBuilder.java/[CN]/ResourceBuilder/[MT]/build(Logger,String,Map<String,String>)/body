{
  String manifestVersion=getManifestVersion(headerMap);
  if (manifestVersion == null || !manifestVersion.equals("2")) {
    throw new BundleException("Unsupported 'Bundle-ManifestVersion' value: " + manifestVersion);
  }
  Version bundleVersion=Version.emptyVersion;
  if (headerMap.get(Constants.BUNDLE_VERSION) != null) {
    bundleVersion=Version.parseVersion(headerMap.get(Constants.BUNDLE_VERSION));
  }
  String bundleSymbolicName=null;
  ParsedHeaderClause bundleCap=parseBundleSymbolicName(headerMap);
  if (bundleCap == null) {
    throw new BundleException("Bundle manifest must include bundle symbolic name");
  }
  bundleSymbolicName=(String)bundleCap.attrs.get(BundleRevision.BUNDLE_NAMESPACE);
  ResourceImpl resource=new ResourceImpl(bundleSymbolicName,bundleVersion);
  if (uri != null) {
    Map<String,Object> attrs=new HashMap<String,Object>();
    attrs.put(UriNamespace.URI_NAMESPACE,uri);
    resource.addCapability(new CapabilityImpl(resource,UriNamespace.URI_NAMESPACE,Collections.<String,String>emptyMap(),attrs));
  }
  if (headerMap.get(Constants.FRAGMENT_HOST) == null) {
    resource.addCapability(new CapabilityImpl(resource,BundleRevision.BUNDLE_NAMESPACE,bundleCap.dirs,bundleCap.attrs));
    String attachment=bundleCap.dirs.get(Constants.FRAGMENT_ATTACHMENT_DIRECTIVE);
    attachment=(attachment == null) ? Constants.FRAGMENT_ATTACHMENT_RESOLVETIME : attachment;
    if (!attachment.equalsIgnoreCase(Constants.FRAGMENT_ATTACHMENT_NEVER)) {
      Map<String,Object> hostAttrs=new HashMap<String,Object>(bundleCap.attrs);
      Object value=hostAttrs.remove(BundleRevision.BUNDLE_NAMESPACE);
      hostAttrs.put(BundleRevision.HOST_NAMESPACE,value);
      resource.addCapability(new CapabilityImpl(resource,BundleRevision.HOST_NAMESPACE,bundleCap.dirs,hostAttrs));
    }
  }
  List<RequirementImpl> hostReqs=parseFragmentHost(logger,resource,headerMap);
  List<ParsedHeaderClause> rbClauses=parseStandardHeader(headerMap.get(Constants.REQUIRE_BUNDLE));
  rbClauses=normalizeRequireClauses(logger,rbClauses);
  List<Requirement> rbReqs=convertRequires(rbClauses,resource);
  List<ParsedHeaderClause> importClauses=parseStandardHeader(headerMap.get(Constants.IMPORT_PACKAGE));
  importClauses=normalizeImportClauses(logger,importClauses);
  List<Requirement> importReqs=convertImports(importClauses,resource);
  List<ParsedHeaderClause> dynamicClauses=parseStandardHeader(headerMap.get(Constants.DYNAMICIMPORT_PACKAGE));
  dynamicClauses=normalizeDynamicImportClauses(logger,dynamicClauses);
  List<Requirement> dynamicReqs=convertImports(dynamicClauses,resource);
  List<ParsedHeaderClause> requireClauses=parseStandardHeader(headerMap.get(Constants.REQUIRE_CAPABILITY));
  requireClauses=normalizeRequireCapabilityClauses(logger,requireClauses);
  List<Requirement> requireReqs=convertRequireCapabilities(requireClauses,resource);
  List<ParsedHeaderClause> exportClauses=parseStandardHeader(headerMap.get(Constants.EXPORT_PACKAGE));
  exportClauses=normalizeExportClauses(logger,exportClauses,bundleSymbolicName,bundleVersion);
  List<Capability> exportCaps=convertExports(exportClauses,resource);
  List<ParsedHeaderClause> provideClauses=parseStandardHeader(headerMap.get(Constants.PROVIDE_CAPABILITY),true);
  provideClauses=normalizeProvideCapabilityClauses(logger,provideClauses);
  List<Capability> provideCaps=convertProvideCapabilities(provideClauses,resource);
  boolean hasServiceReferenceCapability=false;
  for (  Capability cap : exportCaps) {
    hasServiceReferenceCapability|=ServiceNamespace.SERVICE_NAMESPACE.equals(cap.getNamespace());
  }
  if (!hasServiceReferenceCapability) {
    List<ParsedHeaderClause> exportServices=parseStandardHeader(headerMap.get(Constants.EXPORT_SERVICE));
    List<Capability> caps=convertExportService(exportServices,resource);
    provideCaps.addAll(caps);
  }
  boolean hasServiceReferenceRequirement=false;
  for (  Requirement req : requireReqs) {
    hasServiceReferenceRequirement|=ServiceNamespace.SERVICE_NAMESPACE.equals(req.getNamespace());
  }
  if (!hasServiceReferenceRequirement) {
    List<ParsedHeaderClause> importServices=parseStandardHeader(headerMap.get(Constants.IMPORT_SERVICE));
    List<Requirement> reqs=convertImportService(importServices,resource);
    requireReqs.addAll(reqs);
  }
  resource.addCapabilities(exportCaps);
  resource.addCapabilities(provideCaps);
  resource.addRequirements(hostReqs);
  resource.addRequirements(importReqs);
  resource.addRequirements(rbReqs);
  resource.addRequirements(requireReqs);
  resource.addRequirements(dynamicReqs);
  return resource;
}
