{
  BundleContext bundleContext=createMock(BundleContext.class);
  Bundle bundle0=createMock(Bundle.class);
  Bundle bundle=createMock(Bundle.class);
  Bundle bundle2=createMock(Bundle.class);
  FrameworkWiring wiring=createMock(FrameworkWiring.class);
  expect(bundleContext.getProperty("fuse.patch.location")).andReturn(storage.toString()).anyTimes();
  replay(bundleContext,bundle);
  ServiceImpl service=new ServiceImpl(bundleContext);
  Iterable<Patch> patches=service.download(patch132.toURI().toURL());
  assertNotNull(patches);
  Iterator<Patch> it=patches.iterator();
  assertTrue(it.hasNext());
  Patch patch=it.next();
  assertNotNull(patch);
  assertEquals("patch-1.3.2",patch.getId());
  assertNotNull(patch.getBundles());
  assertEquals(1,patch.getBundles().size());
  Iterator<String> itb=patch.getBundles().iterator();
  assertEquals(bundlev132.toURI().toURL().toString(),itb.next());
  assertNull(patch.getResult());
  verify(bundleContext,bundle);
  reset(bundleContext,bundle);
  expect(bundleContext.getBundles()).andReturn(new Bundle[]{bundle});
  expect(bundle.getSymbolicName()).andReturn("my-bsn");
  expect(bundle.getVersion()).andReturn(new Version("1.3.1"));
  expect(bundle.getLocation()).andReturn("location");
  replay(bundleContext,bundle);
  Result result=patch.simulate();
  assertNotNull(result);
  assertNull(patch.getResult());
  assertTrue(result.isSimulation());
  verify(bundleContext,bundle);
  reset(bundleContext,bundle);
  expect(bundleContext.getProperty("fuse.patch.location")).andReturn(storage.toString()).anyTimes();
  replay(bundleContext,bundle);
  service=new ServiceImpl(bundleContext);
  patches=service.getPatches();
  assertNotNull(patches);
  it=patches.iterator();
  assertTrue(it.hasNext());
  patch=it.next();
  assertNotNull(patch);
  assertEquals("patch-1.3.2",patch.getId());
  assertNotNull(patch.getBundles());
  assertEquals(1,patch.getBundles().size());
  itb=patch.getBundles().iterator();
  assertEquals(bundlev132.toURI().toURL().toString(),itb.next());
  assertNull(patch.getResult());
  verify(bundleContext,bundle);
  reset(bundleContext,bundle);
  expect(bundleContext.getBundles()).andReturn(new Bundle[]{bundle});
  expect(bundle.getSymbolicName()).andReturn("my-bsn");
  expect(bundle.getVersion()).andReturn(new Version("1.3.1"));
  expect(bundle.getLocation()).andReturn("location");
  bundle.uninstall();
  expect(bundleContext.installBundle(bundlev132.toURI().toURL().toString())).andReturn(bundle2);
  expect(bundleContext.getBundles()).andReturn(new Bundle[]{bundle2});
  expect(bundle2.getState()).andReturn(Bundle.INSTALLED);
  expect(bundle2.getHeaders()).andReturn(new Hashtable());
  expect(bundle.getState()).andReturn(Bundle.UNINSTALLED);
  expect(bundleContext.getBundle(0)).andReturn(bundle0);
  expect(bundle0.adapt(FrameworkWiring.class)).andReturn(wiring);
  wiring.refreshBundles(eq(asSet(bundle2,bundle)),anyObject(FrameworkListener[].class));
  expectLastCall().andAnswer(new IAnswer<Object>(){
    @Override public Object answer() throws Throwable {
      for (      FrameworkListener l : (FrameworkListener[])(EasyMock.getCurrentArguments()[1])) {
        l.frameworkEvent(null);
      }
      return null;
    }
  }
);
  replay(bundleContext,bundle0,bundle,bundle2,wiring);
  result=patch.install();
  assertNotNull(result);
  assertSame(result,patch.getResult());
  assertFalse(patch.getResult().isSimulation());
  verify(bundleContext,bundle);
  reset(bundleContext,bundle);
  expect(bundleContext.getProperty("fuse.patch.location")).andReturn(storage.toString()).anyTimes();
  replay(bundleContext,bundle);
  service=new ServiceImpl(bundleContext);
  patches=service.getPatches();
  assertNotNull(patches);
  it=patches.iterator();
  assertTrue(it.hasNext());
  patch=it.next();
  assertNotNull(patch);
  assertEquals("patch-1.3.2",patch.getId());
  assertNotNull(patch.getBundles());
  assertEquals(1,patch.getBundles().size());
  itb=patch.getBundles().iterator();
  assertEquals(bundlev132.toURI().toURL().toString(),itb.next());
  assertNotNull(patch.getResult());
  verify(bundleContext,bundle);
}
