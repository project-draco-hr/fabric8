{
  int limit=Config.analyzeLimit;
  int show=Config.analyzeShow;
  ClientRequest req=new ClientRequest(hash);
  LOGGER.debug("\tclient: {}",req);
  Query queryEnd=new SortedQuery(req.getSearch(),req.getFrom(),req.getTo(),0,limit,Config.timestamp,"desc");
  List<String> indicesEnd=Kelastic.getIndices(req.getFrom(),req.getTo());
  ObjectNode resultEnd=new KelasticMulti(queryEnd,indicesEnd).getResponse();
  if (resultEnd.get("hits").get("hits").size() < limit) {
    limit=resultEnd.get("hits").get("hits").size() / 2;
    queryEnd=new SortedQuery(req.getSearch(),req.getFrom(),req.getTo(),0,limit,Config.timestamp,"desc");
    resultEnd=new KelasticMulti(queryEnd,indicesEnd).getResponse();
  }
  Map<String,Integer> countEnd=KelasticResponse.countFields(resultEnd,field);
  Query queryBegin=new SortedQuery(req.getSearch(),req.getFrom(),req.getTo(),0,limit,Config.timestamp,"asc");
  List<String> indicesBegin=Kelastic.getIndices(req.getFrom(),req.getTo());
  Collections.reverse(indicesBegin);
  ObjectNode resultBegin=new KelasticMulti(queryBegin,indicesBegin).getResponse();
  Map<String,Integer> countBegin=KelasticResponse.countFields(resultBegin,field);
  ObjectNode time=((ObjectNode)resultEnd.get("kibana")).putObject("time");
  time.put("from",formatDate(new Date(req.getFrom())));
  time.put("to",formatDate(new Date(req.getTo())));
  List<ObjectNode> trends=new ArrayList<ObjectNode>();
  int count=resultEnd.get("hits").get("hits").size();
  for (  Map.Entry<String,Integer> entry : countEnd.entrySet()) {
    String key=entry.getKey();
    int value=entry.getValue();
    int first=countBegin.containsKey(key) ? countBegin.get(key) : 0;
    ObjectNode n=resultEnd.objectNode();
    n.put("id",key);
    n.put("count",value);
    n.put("first",first);
    n.put("trend",(((float)value) / count - ((float)first) / count) * 100.0f);
    trends.add(n);
  }
  Collections.sort(trends,new Comparator<ObjectNode>(){
    @Override public int compare(    ObjectNode o1,    ObjectNode o2){
      Double t1=Math.abs(o1.get("trend").asDouble());
      Double t2=Math.abs(o2.get("trend").asDouble());
      return t2.compareTo(t1);
    }
  }
);
  ArrayNode hits=resultEnd.arrayNode();
  for (  ObjectNode n : trends) {
    hits.add(n);
  }
  ((ObjectNode)resultEnd.get("hits")).put("count",resultEnd.get("hits").get("hits").size());
  ((ObjectNode)resultEnd.get("hits")).put("hits",hits);
  String str=Json.serialize(resultEnd);
  return str;
}
