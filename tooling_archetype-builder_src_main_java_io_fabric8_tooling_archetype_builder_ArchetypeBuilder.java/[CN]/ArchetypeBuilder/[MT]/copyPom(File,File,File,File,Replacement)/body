{
  LOG.info("Parsing " + pom);
  String text=replaceFn.replace(FileUtils.readFileToString(pom));
  Document doc=parseXml(new InputSource(new StringReader(text)));
  Element root=doc.getDocumentElement();
  Set<String> propertyNameSet=new TreeSet<String>();
  if (root != null) {
    NodeList parents=root.getElementsByTagName("parent");
    if (parents.getLength() > 0) {
      root.removeChild(parents.item(0));
    }
    Set<String> pomPropertyNames=new HashSet<String>();
    NodeList propertyElements=root.getElementsByTagName("properties");
    if (propertyElements.getLength() > 0) {
      Element propertyElement=(Element)propertyElements.item(0);
      NodeList children=propertyElement.getChildNodes();
      for (int cn=0; cn < children.getLength(); cn++) {
        Node e=children.item(cn);
        if (e instanceof Element) {
          pomPropertyNames.add(e.getNodeName());
        }
      }
    }
    LOG.debug("Found <properties> in the pom: {}",pomPropertyNames);
    NodeList children=root.getChildNodes();
    for (int cn=0; cn < children.getLength(); cn++) {
      Node e=children.item(cn);
      if (e instanceof Element) {
        String cText=e.getTextContent();
        String prefix="${";
        if (cText.startsWith(prefix)) {
          int offset=prefix.length();
          int idx=text.indexOf("}",offset + 1);
          if (idx > 0) {
            String name=text.substring(offset,idx);
            if (!pomPropertyNames.contains(name) && isValidRequiredPropertyName(name)) {
              propertyNameSet.add(name);
            }
          }
        }
      }
    }
    List<String> beforeNames=Arrays.asList("artifactId","version","packaging","name","properties");
    replaceOrAddElementText(doc,root,"version","${version}",beforeNames);
    replaceOrAddElementText(doc,root,"artifactId","${artifactId}",beforeNames);
    replaceOrAddElementText(doc,root,"groupId","${groupId}",beforeNames);
  }
  outFile.getParentFile().mkdirs();
  LSOutput output=lsDom.createLSOutput();
  FileWriter fileWriter=new FileWriter(outFile);
  output.setCharacterStream(fileWriter);
  lsSerializer.write(doc,output);
  fileWriter.close();
  String archetypeXmlText=null;
  if (metadataXmlFile.exists()) {
    archetypeXmlText=FileUtils.readFileToString(metadataXmlFile);
  }
 else {
    archetypeXmlText=defaultArchetypeXmlText();
  }
  Document archDoc=parseXml(new InputSource(new StringReader(archetypeXmlText)));
  Element archRoot=archDoc.getDocumentElement();
  LOG.debug(("Found property names: {}"),propertyNameSet);
  if (archRoot != null) {
    Element requiredProperties=replaceOrAddElement(archDoc,archRoot,"requiredProperties",Arrays.asList("fileSets"));
    for (    String propertyName : propertyNameSet) {
      requiredProperties.appendChild(archDoc.createTextNode("\n    "));
      Element requiredProperty=archDoc.createElement("requiredProperty");
      requiredProperties.appendChild(requiredProperty);
      requiredProperty.setAttribute("key",propertyName);
      requiredProperty.appendChild(archDoc.createTextNode("\n      "));
      Element defaultValue=archDoc.createElement("defaultValue");
      requiredProperty.appendChild(defaultValue);
      defaultValue.appendChild(archDoc.createTextNode("${" + propertyName + "}"));
      requiredProperty.appendChild(archDoc.createTextNode("\n    "));
    }
    requiredProperties.appendChild(archDoc.createTextNode("\n  "));
  }
  metadataXmlOutFile.getParentFile().mkdirs();
  output=lsDom.createLSOutput();
  fileWriter=new FileWriter(metadataXmlOutFile);
  output.setCharacterStream(fileWriter);
  lsSerializer.write(archDoc,output);
  fileWriter.close();
}
