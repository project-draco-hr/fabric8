{
  if (!(isPrimitive() || descriptor != null)) {
    return;
  }
  String packageName=generator.getMarshallerPackage();
  File file=new File(generator.getOutputDirectory() + File.separator + new String(packageName).replace(".",File.separator)+ File.separator+ typeMapping.getClassName()+ "Marshaller.java");
  file.getParentFile().mkdirs();
  if (file.exists()) {
    file.delete();
  }
  BufferedWriter writer=new BufferedWriter(new FileWriter(file));
  Utils.writeJavaCopyWrite(writer);
  writer.write("package " + packageName + ";\n");
  writer.newLine();
  if (writeImports(writer,generator,true)) {
    writer.newLine();
  }
  Utils.writeAutoGeneratedWarning(writer,0);
  if (descriptor != null) {
    writer.write("public class " + typeMapping.getShortName() + "Marshaller implements DescribedTypeMarshaller<"+ typeMapping+ ">{");
    writer.newLine();
    writer.newLine();
    writer.write(Utils.tab(1) + "static final " + typeMapping+ "Marshaller SINGLETON = new "+ typeMapping+ "Marshaller();");
    writer.newLine();
    writer.write(Utils.tab(1) + "private static final Encoded<" + getValueMapping()+ "> NULL_ENCODED = new NullEncoded<"+ getValueMapping()+ ">();");
    writer.newLine();
    writer.newLine();
    writer.write(Utils.tab(1) + "public static final String SYMBOLIC_ID = \"" + descriptor.getSymbolicName()+ "\";");
    writer.newLine();
    writer.write(Utils.tab(1) + "//Format code: " + descriptor.getFormatCode()+ ":");
    writer.newLine();
    writer.write(Utils.tab(1) + "public static final long CATEGORY = " + descriptor.getCategory()+ ";");
    writer.newLine();
    writer.write(Utils.tab(1) + "public static final long DESCRIPTOR_ID = " + descriptor.getDescriptorId()+ ";");
    writer.newLine();
    writer.write(Utils.tab(1) + "public static final long NUMERIC_ID = CATEGORY << 32 | DESCRIPTOR_ID; //(" + (descriptor.getCategory() << 32 | descriptor.getDescriptorId())+ "L)");
    writer.newLine();
    writer.write(Utils.tab(1) + "//Hard coded descriptor:");
    writer.newLine();
    writer.write(Utils.tab(1) + "public static final EncodedBuffer DESCRIPTOR = FormatCategory.createBuffer(new Buffer(new byte [] {");
    writer.newLine();
    writer.write(Utils.tab(2) + "(byte) 0x80,                                         // ulong descriptor encoding)");
    writer.newLine();
    writer.write(Utils.tab(2));
    String categoryHex=Utils.padHex(descriptor.getFormatCode().substring(2,descriptor.getFormatCode().indexOf(":")),8);
    for (int i=0; i < 8; i+=2) {
      writer.write("(byte) 0x" + categoryHex.substring(i,i + 2) + ", ");
    }
    writer.write(" // CATEGORY CODE");
    writer.newLine();
    writer.write(Utils.tab(2));
    String descriptorIdHex=Utils.padHex(descriptor.getFormatCode().substring(descriptor.getFormatCode().indexOf(":") + 3),8);
    for (int i=0; i < 8; i+=2) {
      writer.write("(byte) 0x" + descriptorIdHex.substring(i,i + 2));
      if (i < 6) {
        writer.write(", ");
      }
    }
    writer.write("   // DESCRIPTOR ID CODE");
    writer.newLine();
    writer.write(Utils.tab(1) + "}), 0);");
    writer.newLine();
    AmqpClass describedType=descriptor.resolveDescribedType();
    if (!(describedType.isMap() || describedType.isList())) {
      throw new UnknownTypeException("Support for " + descriptor.getDescribedType() + " as a described type isn't yet implemented");
    }
    writeEncodings(writer);
    writer.newLine();
    writer.write(Utils.tab(1) + "public static final Encoded<" + getValueMapping()+ "> encode("+ typeMapping+ " value) throws AmqpEncodingError {");
    writer.newLine();
    writer.write(Utils.tab(2) + "return new " + typeMapping.getJavaType()+ "Encoded(value);");
    writer.newLine();
    writer.write(Utils.tab(1) + "}");
    writer.newLine();
    writer.newLine();
    writer.write(Utils.tab(1) + "static final Encoded<" + getValueMapping()+ "> createEncoded(Buffer source, int offset) throws AmqpEncodingError {");
    writer.newLine();
    writer.write(Utils.tab(2) + "return createEncoded(FormatCategory.createBuffer(source, offset));");
    writer.newLine();
    writer.write(Utils.tab(1) + "}");
    writer.newLine();
    writer.newLine();
    writer.write(Utils.tab(1) + "static final Encoded<" + getValueMapping()+ "> createEncoded(DataInput in) throws IOException, AmqpEncodingError {");
    writer.newLine();
    writer.write(Utils.tab(2) + "return createEncoded(FormatCategory.createBuffer(in.readByte(), in));");
    writer.newLine();
    writer.write(Utils.tab(1) + "}");
    writer.newLine();
    writer.newLine();
    writer.write(Utils.tab(1) + "static final Encoded<" + getValueMapping()+ "> createEncoded(EncodedBuffer buffer) throws AmqpEncodingError {");
    writer.newLine();
    writer.write(Utils.tab(2) + "byte fc = buffer.getEncodingFormatCode();");
    writer.newLine();
    writer.write(Utils.tab(2) + "if (fc == Encoder.NULL_FORMAT_CODE) {");
    writer.newLine();
    writer.write(Utils.tab(3) + "return NULL_ENCODED;");
    writer.newLine();
    writer.write(Utils.tab(2) + "}");
    writer.newLine();
    writer.newLine();
    writer.write(Utils.tab(2) + "DescribedBuffer db = buffer.asDescribed();");
    writer.newLine();
    writer.write(Utils.tab(2) + TypeRegistry.any().typeMapping + " descriptor = AmqpMarshaller.SINGLETON.decodeType(db.getDescriptorBuffer());");
    writer.newLine();
    writer.write(Utils.tab(2) + "if(!(descriptor instanceof AmqpUlong && ((AmqpUlong)descriptor).getValue().longValue() == NUMERIC_ID ||");
    writer.newLine();
    writer.write(Utils.tab(3) + "   descriptor instanceof AmqpSymbol && ((AmqpSymbol)descriptor).getValue().equals(SYMBOLIC_ID))) {");
    writer.newLine();
    writer.write(Utils.tab(3) + "throw new UnexpectedTypeException(\"descriptor mismatch: \" + descriptor);");
    writer.newLine();
    writer.write(Utils.tab(2) + "}");
    writer.newLine();
    writer.write(Utils.tab(2) + "return new " + getJavaType()+ "Encoded(db);");
    writer.newLine();
    writer.write(Utils.tab(1) + "}");
    writer.newLine();
    writer.newLine();
    writer.write(Utils.tab(1) + "public final " + bufferMapping+ " decodeDescribedType("+ TypeRegistry.any().typeMapping+ " descriptor, DescribedBuffer encoded) throws AmqpEncodingError {");
    writer.newLine();
    writer.write(Utils.tab(2) + "return " + bufferMapping+ ".create(new "+ getJavaType()+ "Encoded(encoded));");
    writer.newLine();
    writer.write(Utils.tab(1) + "}");
    writer.newLine();
  }
 else   if (isPrimitive()) {
    writer.write("public class " + typeMapping.getShortName() + "Marshaller {");
    writer.newLine();
    writer.newLine();
    writer.write(Utils.tab(1) + "private static final Encoder ENCODER = Encoder.SINGLETON;");
    writer.newLine();
    writer.write(Utils.tab(1) + "private static final Encoded<" + getValueMapping()+ "> NULL_ENCODED = new NullEncoded<"+ getValueMapping()+ ">();");
    writer.newLine();
    writeEncodings(writer);
    writer.newLine();
    if (!hasMultipleEncodings() && !hasNonFixedEncoding()) {
      writer.newLine();
      writer.write(Utils.tab(1) + "public static final Encoded<" + getValueMapping()+ "> encode("+ getJavaType()+ " data) throws AmqpEncodingError {");
      writer.newLine();
      writer.write(Utils.tab(2) + "if(data == null) {");
      writer.newLine();
      writer.write(Utils.tab(3) + "return NULL_ENCODED;");
      writer.newLine();
      writer.write(Utils.tab(2) + "}");
      writer.newLine();
      writer.write(Utils.tab(2) + "return new " + getJavaType()+ "Encoded(data.getValue());");
      writer.newLine();
      writer.write(Utils.tab(1) + "}");
      writer.newLine();
      writer.newLine();
      writer.write(Utils.tab(1) + "static final Encoded<" + getValueMapping()+ "> createEncoded(Buffer source, int offset) throws AmqpEncodingError {");
      writer.newLine();
      writer.write(Utils.tab(2) + "return createEncoded(FormatCategory.createBuffer(source, offset));");
      writer.newLine();
      writer.write(Utils.tab(1) + "}");
      writer.newLine();
      writer.newLine();
      writer.write(Utils.tab(1) + "static final Encoded<" + getValueMapping()+ "> createEncoded(DataInput in) throws IOException, AmqpEncodingError {");
      writer.newLine();
      writer.write(Utils.tab(2) + "return createEncoded(FormatCategory.createBuffer(in.readByte(), in));");
      writer.newLine();
      writer.write(Utils.tab(1) + "}");
      writer.newLine();
      writer.newLine();
      writer.write(Utils.tab(1) + "static final Encoded<" + getValueMapping()+ "> createEncoded(EncodedBuffer buffer) throws AmqpEncodingError {");
      writer.newLine();
      writer.write(Utils.tab(2) + "if(buffer.getEncodingFormatCode() == AmqpNullMarshaller.FORMAT_CODE) {");
      writer.newLine();
      writer.write(Utils.tab(3) + "return new NullEncoded<" + getValueMapping()+ ">();");
      writer.newLine();
      writer.write(Utils.tab(2) + "}");
      writer.newLine();
      writer.write(Utils.tab(2) + "if(buffer.getEncodingFormatCode() != FORMAT_CODE) {");
      writer.newLine();
      writer.write(Utils.tab(3) + "throw new AmqpEncodingError(\"Unexpected format for " + typeMapping.getShortName()+ " expected: \" + FORMAT_CODE);");
      writer.newLine();
      writer.write(Utils.tab(2) + "}");
      writer.newLine();
      writer.write(Utils.tab(2) + "return new " + typeMapping.getJavaType()+ "Encoded(buffer);");
      writer.newLine();
      writer.write(Utils.tab(1) + "}");
      writer.newLine();
    }
 else {
      writer.newLine();
      writer.write(Utils.tab(1) + "private static final " + getEncodingName(false)+ " chooseEncoding("+ getJavaType()+ " val) throws AmqpEncodingError {");
      writer.newLine();
      if (isMutable()) {
        writer.write(Utils.tab(2) + "return Encoder.choose" + Utils.capFirst(name)+ "Encoding(val);");
      }
 else {
        writer.write(Utils.tab(2) + "return Encoder.choose" + Utils.capFirst(name)+ "Encoding(val.getValue());");
      }
      writer.newLine();
      writer.write(Utils.tab(1) + "}");
      writer.newLine();
      writer.newLine();
      writer.write(Utils.tab(1) + "private static final " + getEncodingName(false)+ " chooseEncoding("+ valueMapping+ " val) throws AmqpEncodingError {");
      writer.newLine();
      writer.write(Utils.tab(2) + "return Encoder.choose" + Utils.capFirst(name)+ "Encoding(val);");
      writer.newLine();
      writer.write(Utils.tab(1) + "}");
      writer.newLine();
      writer.newLine();
      writer.write(Utils.tab(1) + "static final Encoded<" + getValueMapping()+ "> encode("+ getJavaType()+ " data) throws AmqpEncodingError {");
      writer.newLine();
      writer.write(Utils.tab(2) + "if(data == null) {");
      writer.newLine();
      writer.write(Utils.tab(3) + "return NULL_ENCODED;");
      writer.newLine();
      writer.write(Utils.tab(2) + "}");
      writer.newLine();
      if (isMutable()) {
        writer.write(Utils.tab(2) + "return " + getEncodingName(false)+ ".createEncoded(chooseEncoding(data).FORMAT_CODE, data);");
      }
 else {
        writer.write(Utils.tab(2) + "return " + getEncodingName(false)+ ".createEncoded(chooseEncoding(data).FORMAT_CODE, data.getValue());");
      }
      writer.newLine();
      writer.write(Utils.tab(1) + "}");
      writer.newLine();
      writer.newLine();
      writer.write(Utils.tab(1) + "static final Encoded<" + getValueMapping()+ "> createEncoded(Buffer source, int offset) throws AmqpEncodingError {");
      writer.newLine();
      writer.write(Utils.tab(2) + "return createEncoded(FormatCategory.createBuffer(source, offset));");
      writer.newLine();
      writer.write(Utils.tab(1) + "}");
      writer.newLine();
      writer.newLine();
      writer.write(Utils.tab(1) + "static final Encoded<" + getValueMapping()+ "> createEncoded("+ getValueMapping()+ " val) throws AmqpEncodingError {");
      writer.newLine();
      writer.write(Utils.tab(2) + "return " + getEncodingName(false)+ ".createEncoded(chooseEncoding(val).FORMAT_CODE, val);");
      writer.newLine();
      writer.write(Utils.tab(1) + "}");
      writer.newLine();
      writer.newLine();
      writer.write(Utils.tab(1) + "static final Encoded<" + getValueMapping()+ "> createEncoded(DataInput in) throws IOException, AmqpEncodingError {");
      writer.newLine();
      writer.write(Utils.tab(2) + "return createEncoded(FormatCategory.createBuffer(in.readByte(), in));");
      writer.newLine();
      writer.write(Utils.tab(1) + "}");
      writer.newLine();
      writer.newLine();
      writer.write(Utils.tab(1) + "static final Encoded<" + getValueMapping()+ "> createEncoded(EncodedBuffer buffer) throws AmqpEncodingError {");
      writer.newLine();
      writer.write(Utils.tab(2) + "if(buffer.getEncodingFormatCode() == AmqpNullMarshaller.FORMAT_CODE) {");
      writer.newLine();
      writer.write(Utils.tab(3) + "return NULL_ENCODED;");
      writer.newLine();
      writer.write(Utils.tab(2) + "}");
      writer.newLine();
      writer.write(Utils.tab(2) + "return " + getEncodingName(false)+ ".createEncoded(buffer);");
      writer.newLine();
      writer.write(Utils.tab(1) + "}");
      writer.newLine();
      if (isList()) {
        writer.newLine();
        writer.write(Utils.tab(1) + "static final Encoded<" + getValueMapping()+ "> createEncoded(DataInput in, ListDecoder decoder) throws IOException, AmqpEncodingError {");
        writer.newLine();
        writer.write(Utils.tab(2) + "return createEncoded(FormatCategory.createBuffer(in.readByte(), in), decoder);");
        writer.newLine();
        writer.write(Utils.tab(1) + "}");
        writer.newLine();
        writer.newLine();
        writer.write(Utils.tab(1) + "static final Encoded<" + getValueMapping()+ "> createEncoded(EncodedBuffer buffer, ListDecoder decoder) throws AmqpEncodingError {");
        writer.newLine();
        writer.write(Utils.tab(2) + "if(buffer.getEncodingFormatCode() == AmqpNullMarshaller.FORMAT_CODE) {");
        writer.newLine();
        writer.write(Utils.tab(3) + "return NULL_ENCODED;");
        writer.newLine();
        writer.write(Utils.tab(2) + "}");
        writer.newLine();
        writer.write(Utils.tab(2) + getJavaType() + "Encoded rc = "+ getEncodingName(false)+ ".createEncoded(buffer);");
        writer.newLine();
        writer.write(Utils.tab(2) + "rc.setDecoder(decoder);");
        writer.newLine();
        writer.write(Utils.tab(2) + "return rc;");
        writer.newLine();
        writer.write(Utils.tab(1) + "}");
        writer.newLine();
      }
      if (isMap()) {
        writer.newLine();
        writer.write(Utils.tab(1) + "static final Encoded<" + getValueMapping()+ "> createEncoded(DataInput in, MapDecoder decoder) throws IOException, AmqpEncodingError {");
        writer.newLine();
        writer.write(Utils.tab(2) + "return createEncoded(FormatCategory.createBuffer(in.readByte(), in), decoder);");
        writer.newLine();
        writer.write(Utils.tab(1) + "}");
        writer.newLine();
        writer.newLine();
        writer.write(Utils.tab(1) + "static final Encoded<" + getValueMapping()+ "> createEncoded(EncodedBuffer buffer, MapDecoder decoder) throws AmqpEncodingError {");
        writer.newLine();
        writer.write(Utils.tab(2) + "if(buffer.getEncodingFormatCode() == AmqpNullMarshaller.FORMAT_CODE) {");
        writer.newLine();
        writer.write(Utils.tab(3) + "return NULL_ENCODED;");
        writer.newLine();
        writer.write(Utils.tab(2) + "}");
        writer.newLine();
        writer.write(Utils.tab(2) + getJavaType() + "Encoded rc = "+ getEncodingName(false)+ ".createEncoded(buffer);");
        writer.newLine();
        writer.write(Utils.tab(2) + "rc.setDecoder(decoder);");
        writer.newLine();
        writer.write(Utils.tab(2) + "return rc;");
        writer.newLine();
        writer.write(Utils.tab(1) + "}");
        writer.newLine();
      }
    }
  }
  writer.write("}");
  writer.newLine();
  writer.flush();
}
