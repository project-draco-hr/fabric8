{
  checkPrerequisites(patches);
  try {
    final Map<String,Result> results=new LinkedHashMap<String,Result>();
    final Map<Bundle,String> toUpdate=new HashMap<Bundle,String>();
    final BundleVersionHistory history=createBundleVersionHistory();
    Map<String,BundleUpdate> allUpdates=new HashMap<String,BundleUpdate>();
    for (    Patch patch : patches) {
      String startup=readFully(new File(System.getProperty("karaf.base"),"etc/startup.properties"));
      String overrides=readFully(new File(System.getProperty("karaf.base"),"etc/overrides.properties"));
      List<BundleUpdate> updates=new ArrayList<BundleUpdate>();
      Bundle[] allBundles=bundleContext.getBundles();
      for (      String url : patch.getBundles()) {
        JarInputStream jis=new JarInputStream(new URL(url).openStream());
        jis.close();
        Manifest manifest=jis.getManifest();
        Attributes att=manifest != null ? manifest.getMainAttributes() : null;
        String sn=att != null ? att.getValue(Constants.BUNDLE_SYMBOLICNAME) : null;
        String vr=att != null ? att.getValue(Constants.BUNDLE_VERSION) : null;
        if (sn == null || vr == null) {
          continue;
        }
        Version v=VersionTable.getVersion(vr);
        VersionRange range=null;
        if (patch.getVersionRange(url) == null) {
          Version lower=new Version(v.getMajor(),v.getMinor(),0);
          if (v.compareTo(lower) > 0) {
            range=new VersionRange(false,lower,v,true);
          }
        }
 else {
          range=new VersionRange(patch.getVersionRange(url));
        }
        if (range != null) {
          for (          Bundle bundle : allBundles) {
            Version oldV=bundle.getVersion();
            if (bundle.getBundleId() != 0 && stripSymbolicName(sn).equals(stripSymbolicName(bundle.getSymbolicName())) && range.contains(oldV)) {
              String location=history.getLocation(bundle);
              BundleUpdate update=new BundleUpdateImpl(sn,v.toString(),url,oldV.toString(),location);
              updates.add(update);
              BundleUpdate oldUpdate=allUpdates.get(sn);
              if (oldUpdate != null) {
                Version upv=VersionTable.getVersion(oldUpdate.getNewVersion());
                if (upv.compareTo(v) < 0) {
                  allUpdates.put(sn,update);
                  toUpdate.put(bundle,url);
                }
              }
 else {
                toUpdate.put(bundle,url);
              }
            }
          }
        }
 else {
          System.err.printf("Skipping bundle %s - unable to process bundle without a version range configuration%n",url);
        }
      }
      if (!simulate) {
        new Offline(new File(System.getProperty("karaf.base"))).applyConfigChanges(((PatchImpl)patch).getPatch());
      }
      Result result=new ResultImpl(patch,simulate,System.currentTimeMillis(),updates,startup,overrides);
      results.put(patch.getId(),result);
    }
    System.out.println("Bundles to update:");
    for (    Map.Entry<Bundle,String> e : toUpdate.entrySet()) {
      System.out.println("    " + e.getKey().getSymbolicName() + "/"+ e.getKey().getVersion().toString()+ " with "+ e.getValue());
    }
    if (simulate) {
      System.out.println("Running simulation only - no bundles are being updated at this time");
    }
 else {
      System.out.println("Installation will begin.  The connection may be lost or the console restarted.");
    }
    System.out.flush();
    if (!simulate) {
      Thread thread=new Thread(){
        public void run(){
          try {
            applyChanges(toUpdate);
            for (            Patch patch : patches) {
              Result result=results.get(patch.getId());
              ((PatchImpl)patch).setResult(result);
              saveResult(result);
            }
          }
 catch (          Exception e) {
            e.printStackTrace(System.err);
            System.err.flush();
          }
        }
      }
;
      if (synchronous) {
        thread.run();
      }
 else {
        thread.start();
      }
    }
    return results;
  }
 catch (  Exception e) {
    throw new PatchException(e);
  }
}
